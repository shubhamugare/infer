{"id": "abduce_001", "source_file": "pulse/abduce.c", "original_function_name": "const_local_no_abduce", "anonymized_function_name": "const_local_no_abduce", "function_code": "int const_local_no_abduce(int* p) {\n  external_func(&p);\n  return p ? *p : 0;\n  // We shouldn't get a stack address escape warning here\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 12, "end_line": 16}}
{"id": "abduce_002", "source_file": "pulse/abduce.c", "original_function_name": "set_ptr", "anonymized_function_name": "set_ptr", "function_code": "void set_ptr(int* ptr, int val) { *ptr = val; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 18, "end_line": 18}}
{"id": "abduce_003", "source_file": "pulse/abduce.c", "original_function_name": "set_ptr_local_array", "anonymized_function_name": "set_ptr_local_array", "function_code": "int set_ptr_local_array() {\n  int buf[2];\n  set_ptr(buf, 1);\n  return buf[0];\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void set_ptr(int* ptr, int val) { *ptr = val; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 20, "end_line": 24}}
{"id": "abduce_004", "source_file": "pulse/abduce.c", "original_function_name": "set_ptr_param_array", "anonymized_function_name": "set_ptr_param_array", "function_code": "int set_ptr_param_array(int buf[]) {\n  set_ptr(buf, 1);\n  return buf[0];\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void set_ptr(int* ptr, int val) { *ptr = val; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 33, "end_line": 36}}
{"id": "abduce_005", "source_file": "pulse/abduce.c", "original_function_name": "set_ptr_param_array_get_null_bad", "anonymized_function_name": "set_ptr_param_array_get_null", "function_code": "void set_ptr_param_array_get_null() {\n  // A null pointer dereference is expected here\n  set_ptr_param_array(NULL);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int set_ptr_param_array(int buf[]) {\n  set_ptr(buf, 1);\n  return buf[0];\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 56, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `set_ptr_param_array` here,parameter `buf` of set_ptr_param_array,when calling `set_ptr` here,parameter `ptr` of set_ptr,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 54, "end_line": 57}}
{"id": "aliasing_001", "source_file": "pulse/aliasing.c", "original_function_name": "local_addr_noalias_bad", "anonymized_function_name": "local_addr_noalias", "function_code": "void local_addr_noalias(int* p) {\n  int* q = NULL;\n  int x = 1;\n  if (&x != p) {\n    *q = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 22, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 18, "end_line": 24}}
{"id": "aliasing_002", "source_file": "pulse/aliasing.c", "original_function_name": "global_addr_alias_bad", "anonymized_function_name": "global_addr_alias", "function_code": "void global_addr_alias(int* p) {\n  int* q = NULL;\n  if (&g == p) {\n    *q = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 30, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 27, "end_line": 32}}
{"id": "angelism_001", "source_file": "pulse/angelism.c", "original_function_name": "by_ref_actual_already_in_footprint", "anonymized_function_name": "by_ref_actual_already_in_footprint", "function_code": "void by_ref_actual_already_in_footprint(struct delicious* param) {\n  int i;\n  struct delicious* ret = bakery(&param);\n  i = param->yum;\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 51, "end_line": 55}}
{"id": "angelism_002", "source_file": "pulse/angelism.c", "original_function_name": "call_by_ref_actual_already_in_footprint_ok", "anonymized_function_name": "call_by_ref_actual_already_in_footprint", "function_code": "void call_by_ref_actual_already_in_footprint() {\n  by_ref_actual_already_in_footprint(NULL); // should not report a warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": ["void by_ref_actual_already_in_footprint(struct delicious* param) {\n  int i;\n  struct delicious* ret = bakery(&param);\n  i = param->yum;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 57, "end_line": 59}}
{"id": "angelism_003", "source_file": "pulse/angelism.c", "original_function_name": "by_ref_actual_already_in_footprint2", "anonymized_function_name": "by_ref_actual_already_in_footprint2", "function_code": "void by_ref_actual_already_in_footprint2(struct delicious* param) {\n  int i;\n  i = param->yum; // should not report a warning\n  struct delicious* ret = bakery(&param);\n  i = param->yum; // should not report a warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 61, "end_line": 66}}
{"id": "angelism_004", "source_file": "pulse/angelism.c", "original_function_name": "call_by_ref_actual_already_in_footprint_bad", "anonymized_function_name": "call_by_ref_actual_already_in_footprint", "function_code": "void call_by_ref_actual_already_in_footprint() {\n  by_ref_actual_already_in_footprint2(NULL); // should report a warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": ["void by_ref_actual_already_in_footprint2(struct delicious* param) {\n  int i;\n  i = param->yum; // should not report a warning\n  struct delicious* ret = bakery(&param);\n  i = param->yum; // should not report a warning\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 1, "absolute_line": 69, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `by_ref_actual_already_in_footprint2` here,parameter `param` of by_ref_actual_already_in_footprint2,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 68, "end_line": 70}}
{"id": "angelism_005", "source_file": "pulse/angelism.c", "original_function_name": "passByRefTwiceOk", "anonymized_function_name": "passByRefTwiceOk", "function_code": "void passByRefTwiceOk() {\n  struct delicious* param;\n  bakery2(&param, &param); // should not report a warning\n  int i = param->yum;\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 72, "end_line": 76}}
{"id": "angelism_006", "source_file": "pulse/angelism.c", "original_function_name": "returnPassByRefDerefOk", "anonymized_function_name": "returnPassByRefDerefOk", "function_code": "void returnPassByRefDerefOk() {\n  struct delicious* ret = returnPassByRef();\n  ret->yum = 2; // should not report a warning\n  free(ret);\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 85, "end_line": 89}}
{"id": "angelism_007", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_by_ref_ptr_ok", "anonymized_function_name": "struct_value_by_ref_ptr", "function_code": "int struct_value_by_ref_ptr() {\n  struct delicious x;\n  struct_ptr_skip(&x);\n  return *x.ptr; // should not report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 95, "end_line": 99}}
{"id": "angelism_008", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_by_ref_ptr_write_before_ok", "anonymized_function_name": "struct_value_by_ref_ptr_write_before", "function_code": "int struct_value_by_ref_ptr_write_before() {\n  struct delicious x;\n  x.ptr = NULL;\n  struct_ptr_skip(&x);\n  return *x.ptr; // should not report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 101, "end_line": 106}}
{"id": "angelism_009", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_by_ref_ptr_write_bad", "anonymized_function_name": "struct_value_by_ref_ptr_write", "function_code": "int struct_value_by_ref_ptr_write() {\n  struct delicious x;\n  struct_ptr_skip(&x);\n  x.ptr = NULL;\n  return *x.ptr; // should report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 112, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 108, "end_line": 113}}
{"id": "angelism_010", "source_file": "pulse/angelism.c", "original_function_name": "setF", "anonymized_function_name": "setF", "function_code": "void setF(struct delicious* x, int val) { x->ptr = val; }\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 115, "end_line": 115}}
{"id": "angelism_011", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_by_ref_callee_write_no_skip_bad", "anonymized_function_name": "struct_value_by_ref_callee_write_no_skip", "function_code": "int struct_value_by_ref_callee_write_no_skip() {\n  struct delicious x;\n  setF(&x, NULL);\n  return *x.ptr; // should report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": ["void setF(struct delicious* x, int val) { x->ptr = val; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 120, "severity": "ERROR", "trace": "is assigned to the null pointer,in call to `setF`,parameter `val` of setF,assigned,return from call to `setF`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 117, "end_line": 121}}
{"id": "angelism_012", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_by_ref_callee_write_skip_bad", "anonymized_function_name": "struct_value_by_ref_callee_write_skip", "function_code": "int struct_value_by_ref_callee_write_skip() {\n  struct delicious x;\n  struct_ptr_skip(&x);\n  setF(&x, NULL);\n  return *x.ptr; // should report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": ["void setF(struct delicious* x, int val) { x->ptr = val; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 127, "severity": "ERROR", "trace": "is assigned to the null pointer,in call to `setF`,parameter `val` of setF,assigned,return from call to `setF`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 123, "end_line": 128}}
{"id": "angelism_013", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_by_ref_write_then_skip_ok", "anonymized_function_name": "struct_value_by_ref_write_then_skip", "function_code": "int struct_value_by_ref_write_then_skip() {\n  struct delicious x;\n  x.ptr = NULL;\n  struct_ptr_skip(&x);\n  return *x.ptr; // should not report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 130, "end_line": 135}}
{"id": "angelism_014", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_skip_null_deref_bad", "anonymized_function_name": "struct_value_skip_null_deref", "function_code": "int struct_value_skip_null_deref() {\n  struct delicious x;\n  x.ptr = NULL;\n  struct_val_skip(x);\n  return *x.ptr; // should report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 141, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 137, "end_line": 142}}
{"id": "angelism_015", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_skip_ok", "anonymized_function_name": "struct_value_skip", "function_code": "int struct_value_skip() {\n  struct delicious x;\n  x.yum = 7;\n  struct_val_skip(x);\n  return 1 / x.yum; // should not report div by zero warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 144, "end_line": 149}}
{"id": "angelism_016", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_from_pointer_skip_ok", "anonymized_function_name": "struct_value_from_pointer_skip", "function_code": "int struct_value_from_pointer_skip(struct delicious* x) {\n  struct_val_skip(*x);\n  return 1 / x->yum; // should not report div by zero warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 151, "end_line": 154}}
{"id": "angelism_017", "source_file": "pulse/angelism.c", "original_function_name": "struct_value_from_pointer_skip_bad", "anonymized_function_name": "struct_value_from_pointer_skip", "function_code": "int struct_value_from_pointer_skip(struct delicious* x) {\n  x->ptr = NULL;\n  struct_val_skip(*x);\n  return 1 / *x->ptr; // should report null deref warning\n}\n", "includes": ["#include <stdlib.h>", "struct delicious {\n  int yum;\n  int* ptr;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 159, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 156, "end_line": 160}}
{"id": "arithmetic_001", "source_file": "pulse/arithmetic.c", "original_function_name": "return_non_negative", "anonymized_function_name": "return_non_negative", "function_code": "int return_non_negative() {\n  int x = random();\n  if (x < 0) {\n    exit(1);\n  }\n  return x;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 11, "end_line": 17}}
{"id": "arithmetic_002", "source_file": "pulse/arithmetic.c", "original_function_name": "return_non_negative_is_non_negative_ok", "anonymized_function_name": "return_non_negative_is_non_negative", "function_code": "void return_non_negative_is_non_negative() {\n  if (return_non_negative() < 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["int return_non_negative() {\n  int x = random();\n  if (x < 0) {\n    exit(1);\n  }\n  return x;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 19, "end_line": 24}}
{"id": "arithmetic_003", "source_file": "pulse/arithmetic.c", "original_function_name": "assume_non_negative", "anonymized_function_name": "assume_non_negative", "function_code": "void assume_non_negative(int x) {\n  if (x < 0) {\n    exit(1);\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 26, "end_line": 30}}
{"id": "arithmetic_004", "source_file": "pulse/arithmetic.c", "original_function_name": "assume_non_negative_is_non_negative_ok", "anonymized_function_name": "assume_non_negative_is_non_negative", "function_code": "void assume_non_negative_is_non_negative() {\n  int x = random();\n  assume_non_negative(x);\n  if (x < 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void assume_non_negative(int x) {\n  if (x < 0) {\n    exit(1);\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 32, "end_line": 39}}
{"id": "arithmetic_005", "source_file": "pulse/arithmetic.c", "original_function_name": "if_negative_then_crash_latent", "anonymized_function_name": "if_negative_then_crash", "function_code": "void if_negative_then_crash(int x) {\n  assume_non_negative(-x);\n  int* p = NULL;\n  *p = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void assume_non_negative(int x) {\n  if (x < 0) {\n    exit(1);\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 3, "absolute_line": 44, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 41, "end_line": 45}}
{"id": "arithmetic_006", "source_file": "pulse/arithmetic.c", "original_function_name": "call_if_negative_then_crash_with_local_bad", "anonymized_function_name": "call_if_negative_then_crash_with_local", "function_code": "void call_if_negative_then_crash_with_local() {\n  int x = random();\n  if_negative_then_crash_latent(x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void if_negative_then_crash_latent(int x) {\n  assume_non_negative(-x);\n  int* p = NULL;\n  *p = 42;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 55, "severity": "ERROR", "trace": "when calling `if_negative_then_crash_latent` here,is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 53, "end_line": 56}}
{"id": "arithmetic_007", "source_file": "pulse/arithmetic.c", "original_function_name": "return_non_negative_float", "anonymized_function_name": "return_non_negative_float", "function_code": "float return_non_negative_float() {\n  float x = ((float)random()) / (2 ^ 31 - 1);\n  if (x < 0.) {\n    exit(1);\n  }\n  return x;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 58, "end_line": 64}}
{"id": "arithmetic_008", "source_file": "pulse/arithmetic.c", "original_function_name": "return_non_negative_float_is_non_negative_ok", "anonymized_function_name": "return_non_negative_float_is_non_negative", "function_code": "void return_non_negative_float_is_non_negative() {\n  if (return_non_negative_float() < 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["float return_non_negative_float() {\n  float x = ((float)random()) / (2 ^ 31 - 1);\n  if (x < 0.) {\n    exit(1);\n  }\n  return x;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 66, "end_line": 71}}
{"id": "arithmetic_009", "source_file": "pulse/arithmetic.c", "original_function_name": "assume_non_negative_float", "anonymized_function_name": "assume_non_negative_float", "function_code": "void assume_non_negative_float(float x) {\n  if (x < 0.) {\n    exit(1);\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 73, "end_line": 77}}
{"id": "arithmetic_010", "source_file": "pulse/arithmetic.c", "original_function_name": "assume_non_negative_float_is_non_negative_ok", "anonymized_function_name": "assume_non_negative_float_is_non_negative", "function_code": "void assume_non_negative_float_is_non_negative() {\n  float x = ((float)random()) / (2 ^ 31 - 1);\n  assume_non_negative_float(x);\n  if (x < 0.) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void assume_non_negative_float(float x) {\n  if (x < 0.) {\n    exit(1);\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 79, "end_line": 86}}
{"id": "array_out_of_bounds_001", "source_file": "pulse/array_out_of_bounds.c", "original_function_name": "nested_array_ok", "anonymized_function_name": "nested_array", "function_code": "void nested_array() {\n  int a[3][4][5];\n  a[2][3][4] = 0;\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 18, "end_line": 21}}
{"id": "assert_001", "source_file": "pulse/assert.c", "original_function_name": "report_on_line_offset_6_bad", "anonymized_function_name": "report_on_line_offset_6", "function_code": "int report_on_line_offset_6(int* p) {\n  assert(p);\n  if (!p) {\n    *p = 42; // unreachable\n  }\n  int* q = NULL;\n  *q = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 6, "absolute_line": 19, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 13, "end_line": 20}}
{"id": "assert_failure_001", "source_file": "pulse/assert_failure.c", "original_function_name": "simple_check", "anonymized_function_name": "simple_check", "function_code": "void simple_check(int x) { assert(x < 3); }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 13, "end_line": 13}}
{"id": "assert_failure_002", "source_file": "pulse/assert_failure.c", "original_function_name": "simple_assertion_failure", "anonymized_function_name": "simple_assertion_failure", "function_code": "void simple_assertion_failure() {\n  int x = 4;\n  simple_check(x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void simple_check(int x) { assert(x < 3); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 15, "end_line": 18}}
{"id": "assert_failure_003", "source_file": "pulse/assert_failure.c", "original_function_name": "no_assertion_failure", "anonymized_function_name": "no_assertion_failure", "function_code": "void no_assertion_failure() {\n  int x = 2;\n  simple_check(x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void simple_check(int x) { assert(x < 3); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 20, "end_line": 23}}
{"id": "assert_failure_004", "source_file": "pulse/assert_failure.c", "original_function_name": "check_node", "anonymized_function_name": "check_node", "function_code": "void check_node(node* n) { assert(n->value < 3); }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 29, "end_line": 29}}
{"id": "assert_failure_005", "source_file": "pulse/assert_failure.c", "original_function_name": "assertion_failure_with_heap", "anonymized_function_name": "assertion_failure_with_heap", "function_code": "node* assertion_failure_with_heap() {\n  node* n = malloc(sizeof(node));\n  if (n != NULL) {\n    n->value = 4;\n    check_node(n);\n  }\n  return n;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void check_node(node* n) { assert(n->value < 3); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 31, "end_line": 38}}
{"id": "assert_failure_006", "source_file": "pulse/assert_failure.c", "original_function_name": "no_assertion_failure_with_heap", "anonymized_function_name": "no_assertion_failure_with_heap", "function_code": "node* no_assertion_failure_with_heap() {\n  node* n = malloc(sizeof(node));\n  if (n != NULL) {\n    n->value = 2;\n    check_node(n);\n  }\n  return n;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void check_node(node* n) { assert(n->value < 3); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 40, "end_line": 47}}
{"id": "assert_failure_007", "source_file": "pulse/assert_failure.c", "original_function_name": "my_assert", "anonymized_function_name": "my_assert", "function_code": "void my_assert(int x) {\n  if (!x) {\n    __infer_fail(\"ASSERTION_FAILURE\");\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 51, "end_line": 55}}
{"id": "assert_failure_008", "source_file": "pulse/assert_failure.c", "original_function_name": "should_not_report_assertion_failure", "anonymized_function_name": "should_not_report_assertion_failure", "function_code": "void should_not_report_assertion_failure(int x) { my_assert(x); }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void my_assert(int x) {\n  if (!x) {\n    __infer_fail(\"ASSERTION_FAILURE\");\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 57, "end_line": 57}}
{"id": "assert_failure_009", "source_file": "pulse/assert_failure.c", "original_function_name": "should_report_assertion_failure", "anonymized_function_name": "should_report_assertion_failure", "function_code": "void should_report_assertion_failure(int x) {\n  x = 0;\n  my_assert(x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void my_assert(int x) {\n  if (!x) {\n    __infer_fail(\"ASSERTION_FAILURE\");\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 59, "end_line": 62}}
{"id": "assert_failure_010", "source_file": "pulse/assert_failure.c", "original_function_name": "check_global", "anonymized_function_name": "check_global", "function_code": "void check_global() { assert(global != 0); }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 66, "end_line": 66}}
{"id": "assert_failure_011", "source_file": "pulse/assert_failure.c", "original_function_name": "skip", "anonymized_function_name": "skip", "function_code": "void skip() {}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 68, "end_line": 68}}
{"id": "assert_failure_012", "source_file": "pulse/assert_failure.c", "original_function_name": "assignment_after_check", "anonymized_function_name": "assignment_after_check", "function_code": "void assignment_after_check() {\n  check_global();\n  global = 0;\n  skip();\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void check_global() { assert(global != 0); }\n", "void skip() {}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 70, "end_line": 74}}
{"id": "assert_failure_013", "source_file": "pulse/assert_failure.c", "original_function_name": "assignemt_before_check", "anonymized_function_name": "assignemt_before_check", "function_code": "void assignemt_before_check() {\n  global = 0;\n  check_global();\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void check_global() { assert(global != 0); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 76, "end_line": 79}}
{"id": "assert_failure_014", "source_file": "pulse/assert_failure.c", "original_function_name": "failure_on_both_branches", "anonymized_function_name": "failure_on_both_branches", "function_code": "void failure_on_both_branches(int x) {\n  if (x > 3) {\n    simple_check(x);\n  } else {\n    simple_check(42);\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void simple_check(int x) { assert(x < 3); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 81, "end_line": 87}}
{"id": "cleanup_attribute_001", "source_file": "pulse/cleanup_attribute.c", "original_function_name": "cleanup_char", "anonymized_function_name": "cleanup_char", "function_code": "void cleanup_char(char** x) { free(*x); }\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 10, "end_line": 10}}
{"id": "cleanup_attribute_002", "source_file": "pulse/cleanup_attribute.c", "original_function_name": "cleanup_int", "anonymized_function_name": "cleanup_int", "function_code": "void cleanup_int(int** x) { free(*x); }\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 12, "end_line": 12}}
{"id": "cleanup_attribute_003", "source_file": "pulse/cleanup_attribute.c", "original_function_name": "no_cleanup", "anonymized_function_name": "no_cleanup", "function_code": "void no_cleanup(int** x) { /* nothing */ }\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 14, "end_line": 14}}
{"id": "cleanup_attribute_004", "source_file": "pulse/cleanup_attribute.c", "original_function_name": "cleanup_malloc_ok", "anonymized_function_name": "cleanup_malloc", "function_code": "void cleanup_malloc() {\n  __attribute__((cleanup(cleanup_int))) int* x;\n  // attribute cleanup is done on *x not x, resulting in NPE, Uninit, and\n  // memleak FPs\n  x = malloc(sizeof(int));\n  if (x != NULL) {\n    *x = 10;\n  }\n  /* x goes out of scope. Cleanup function called - no leak */\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 16, "end_line": 25}}
{"id": "cleanup_attribute_005", "source_file": "pulse/cleanup_attribute.c", "original_function_name": "cleanup_string_ok", "anonymized_function_name": "cleanup_string", "function_code": "void cleanup_string() {\n  __attribute__((cleanup(cleanup_char))) char* s;\n  s = strdup(\"demo string\");\n  /* s goes out of scope. Cleanup function called - no leak */\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 34, "end_line": 38}}
{"id": "compound_literal_001", "source_file": "pulse/compound_literal.c", "original_function_name": "return_zero", "anonymized_function_name": "return_zero", "function_code": "int return_zero() { return ((struct point){.y = 32, .x = 0}).x; }\n", "includes": ["#include <stdlib.h>", "struct point {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 15, "end_line": 15}}
{"id": "compound_literal_002", "source_file": "pulse/compound_literal.c", "original_function_name": "detect_zero_bad", "anonymized_function_name": "detect_zero", "function_code": "int detect_zero() {\n  if (return_zero() == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct point {\n  int x;\n  int y;\n};"], "dependencies": ["int return_zero() { return ((struct point){.y = 32, .x = 0}).x; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 20, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 17, "end_line": 22}}
{"id": "compound_literal_003", "source_file": "pulse/compound_literal.c", "original_function_name": "detect_zero_ok", "anonymized_function_name": "detect_zero", "function_code": "int detect_zero() {\n  if (return_zero() != 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct point {\n  int x;\n  int y;\n};"], "dependencies": ["int return_zero() { return ((struct point){.y = 32, .x = 0}).x; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 24, "end_line": 29}}
{"id": "dangling_deref_001", "source_file": "pulse/dangling_deref.c", "original_function_name": "set42", "anonymized_function_name": "set42", "function_code": "int* set42(int* x) {\n  *x = 42;\n  return x;\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 11, "end_line": 14}}
{"id": "dangling_deref_002", "source_file": "pulse/dangling_deref.c", "original_function_name": "no_dangling_deref_ok", "anonymized_function_name": "no_dangling_deref", "function_code": "void no_dangling_deref() {\n  int w, *z;\n  z = set42(&w);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": ["int* set42(int* x) {\n  *x = 42;\n  return x;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 16, "end_line": 19}}
{"id": "dangling_deref_003", "source_file": "pulse/dangling_deref.c", "original_function_name": "no_dangling_deref1_ok", "anonymized_function_name": "no_dangling_deref1", "function_code": "void no_dangling_deref1() {\n  int* y = malloc(sizeof(int));\n  int* z;\n  if (y) {\n    z = set42(y);\n    free(y);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": ["int* set42(int* x) {\n  *x = 42;\n  return x;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 21, "end_line": 28}}
{"id": "dangling_deref_004", "source_file": "pulse/dangling_deref.c", "original_function_name": "dangling_deref_bad", "anonymized_function_name": "dangling_deref", "function_code": "void dangling_deref() {\n  int* y;\n  int* z;\n  z = set42(y);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": ["int* set42(int* x) {\n  *x = 42;\n  return x;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 33, "severity": "ERROR", "trace": "variable `y` declared here,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "uninitialized_value", "start_line": 30, "end_line": 34}}
{"id": "dangling_deref_005", "source_file": "pulse/dangling_deref.c", "original_function_name": "intraproc_dangling_deref_bad", "anonymized_function_name": "intraproc_dangling_deref", "function_code": "void intraproc_dangling_deref() {\n  int* y;\n  int* z;\n  *y = 42;\n  z = y;\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 39, "severity": "ERROR", "trace": "variable `y` declared here,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "uninitialized_value", "start_line": 36, "end_line": 41}}
{"id": "dangling_deref_006", "source_file": "pulse/dangling_deref.c", "original_function_name": "union_ok", "anonymized_function_name": "union", "function_code": "short union(int* param) {\n  union {\n    int* a;\n    short* b;\n  } u;\n  u.a = param;\n  short* p = u.b;\n  return *p;\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 43, "end_line": 51}}
{"id": "enum_001", "source_file": "pulse/enum.c", "original_function_name": "other_enum_main", "anonymized_function_name": "other_enum_main", "function_code": "int other_enum_main() {\n  enum Foo foo_a = A;\n  enum Foo foo_b = B;\n  enum Foo foo_c = C;\n  enum Foo foo_d = D;\n  enum Foo foo_e = E;\n  enum Foo foo_f = F;\n  enum Foo foo_g = G;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 12, "end_line": 20}}
{"id": "enum_002", "source_file": "pulse/enum.c", "original_function_name": "enum_values_ok", "anonymized_function_name": "enum_values", "function_code": "void enum_values() {\n  enum Foo foo_g = G;\n  enum Foo foo_a = A;\n  if (foo_g != 12 || foo_a != 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 22, "end_line": 29}}
{"id": "enum_003", "source_file": "pulse/enum.c", "original_function_name": "enum_values_bad", "anonymized_function_name": "enum_values", "function_code": "void enum_values() {\n  enum Foo foo_g = G;\n  enum Foo foo_a = A;\n  if (foo_g == 12 && foo_a == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 36, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 31, "end_line": 38}}
{"id": "exit_example_001", "source_file": "pulse/exit_example.c", "original_function_name": "exit_example_bad", "anonymized_function_name": "exit_example", "function_code": "void exit_example() {\n  int* p = NULL;\n  if (p) {\n    exit(1);\n  }\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 14, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 9, "end_line": 15}}
{"id": "exit_example_002", "source_file": "pulse/exit_example.c", "original_function_name": "direct_exit_example_ok", "anonymized_function_name": "direct_exit_example", "function_code": "void direct_exit_example() {\n  int* p = NULL;\n  exit(1);\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 17, "end_line": 21}}
{"id": "exit_example_003", "source_file": "pulse/exit_example.c", "original_function_name": "exit_wrapper", "anonymized_function_name": "exit_wrapper", "function_code": "void exit_wrapper() { exit(1); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 23, "end_line": 23}}
{"id": "exit_example_004", "source_file": "pulse/exit_example.c", "original_function_name": "indirect_exit_example_ok", "anonymized_function_name": "indirect_exit_example", "function_code": "void indirect_exit_example() {\n  int* p = NULL;\n  exit_wrapper();\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void exit_wrapper() { exit(1); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 25, "end_line": 29}}
{"id": "exit_example_005", "source_file": "pulse/exit_example.c", "original_function_name": "direct_abort_example_ok", "anonymized_function_name": "direct_abort_example", "function_code": "void direct_abort_example() {\n  int* p = NULL;\n  abort();\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 31, "end_line": 35}}
{"id": "exit_example_006", "source_file": "pulse/exit_example.c", "original_function_name": "abort_wrapper", "anonymized_function_name": "abort_wrapper", "function_code": "void abort_wrapper() { abort(); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 37, "end_line": 37}}
{"id": "exit_example_007", "source_file": "pulse/exit_example.c", "original_function_name": "indirect_abort_example_ok", "anonymized_function_name": "indirect_abort_example", "function_code": "void indirect_abort_example() {\n  int* p = NULL;\n  abort_wrapper();\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void abort_wrapper() { abort(); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 39, "end_line": 43}}
{"id": "field_taint_001", "source_file": "pulse/field_taint.c", "original_function_name": "test_taint_field_bad", "anonymized_function_name": "test_taint_field", "function_code": "void test_taint_field(structure s) {\n  taint_manipulated(s);\n  sink_int(s.manipulated);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 2, "absolute_line": 28, "severity": "ERROR", "trace": "source of the taint here: field `manipulated` of value passed as argument `#0` to `taint_manipulated` with kind `Simple`,flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 26, "end_line": 29}}
{"id": "field_taint_002", "source_file": "pulse/field_taint.c", "original_function_name": "test_taint_field_good", "anonymized_function_name": "test_taint_field", "function_code": "void test_taint_field(structure s) {\n  taint_manipulated(s);\n  sink_int(s.other);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 31, "end_line": 34}}
{"id": "field_taint_003", "source_file": "pulse/field_taint.c", "original_function_name": "test_sink_field_bad", "anonymized_function_name": "test_sink_field", "function_code": "void test_sink_field(structure s) {\n  int tainted = int_source();\n  s.manipulated = tainted;\n  sink_manipulated(s);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 3, "absolute_line": 39, "severity": "ERROR", "trace": "source of the taint here: value returned from `int_source` with kind `Simple`,flows to this sink: field `manipulated` of value passed as argument `#0` to `sink_manipulated` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 36, "end_line": 40}}
{"id": "field_taint_004", "source_file": "pulse/field_taint.c", "original_function_name": "test_sink_field_good", "anonymized_function_name": "test_sink_field", "function_code": "void test_sink_field(structure s) {\n  int tainted = int_source();\n  s.other = tainted;\n  sink_manipulated(s);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 42, "end_line": 46}}
{"id": "field_taint_005", "source_file": "pulse/field_taint.c", "original_function_name": "test_sanitize_field_bad", "anonymized_function_name": "test_sanitize_field", "function_code": "void test_sanitize_field(structure s) {\n  // The 2 lines below are necessary because tainting propagates down\n  // what is known in the memory at the moment of tainting and it is never\n  // propagated again when a new manipulated appears. `s.other` and\n  // `s.manipulated` need to have different values otherwise they are both\n  // referencing the same value and sanitizing one would sanitize the other\n  s.other = 2; // makes s.other exist in memory before tainting s\n  s.manipulated = 1; // makes s.manipulated exist in memory before tainting s\n  taint_structure(s);\n  sanitize_manipulated(s);\n  sink_int(s.other);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 10, "absolute_line": 58, "severity": "ERROR", "trace": "source of the taint here: value passed as argument `#0` to `taint_structure` with kind `Simple`,flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 48, "end_line": 59}}
{"id": "field_taint_006", "source_file": "pulse/field_taint.c", "original_function_name": "test_sanitize_field_good", "anonymized_function_name": "test_sanitize_field", "function_code": "void test_sanitize_field(structure s) {\n  s.other = 2; // makes s.other exist in memory before tainting s\n  s.manipulated = 1; // makes s.manipulated exist in memory before tainting s\n  taint_structure(s);\n  sanitize_manipulated(s);\n  sink_manipulated(s);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 61, "end_line": 67}}
{"id": "field_taint_007", "source_file": "pulse/field_taint.c", "original_function_name": "test_propagate_to_field_bad", "anonymized_function_name": "test_propagate_to_field", "function_code": "void test_propagate_to_field(structure s) {\n  int tainted = int_source();\n  propagate_to_manipulated(s, tainted);\n  sink_int(s.manipulated);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 3, "absolute_line": 71, "severity": "ERROR", "trace": "source of the taint here: value returned from `int_source` with kind `Simple`,in call to `propagate_to_manipulated`,flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 68, "end_line": 72}}
{"id": "field_taint_008", "source_file": "pulse/field_taint.c", "original_function_name": "test_propagate_to_field_good", "anonymized_function_name": "test_propagate_to_field", "function_code": "void test_propagate_to_field(structure s) {\n  int tainted = int_source();\n  propagate_to_manipulated(s, tainted);\n  sink_int(s.other);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 74, "end_line": 78}}
{"id": "field_taint_009", "source_file": "pulse/field_taint.c", "original_function_name": "test_taint_field_with_indirections_bad", "anonymized_function_name": "test_taint_field_with_indirections", "function_code": "void test_taint_field_with_indirections(structure s) {\n  structure* s_ptr = &s;\n  structure** s_ptr_ptr = &s_ptr;\n  taint_manipulated_with_indirections(s_ptr_ptr);\n  sink_int((**s_ptr_ptr).manipulated);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 4, "absolute_line": 84, "severity": "ERROR", "trace": "source of the taint here: field `manipulated` of value passed as argument `#0` to `taint_manipulated_with_indirections` with kind `Simple`,flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 80, "end_line": 85}}
{"id": "field_taint_010", "source_file": "pulse/field_taint.c", "original_function_name": "test_taint_field_with_indirections_good", "anonymized_function_name": "test_taint_field_with_indirections", "function_code": "void test_taint_field_with_indirections(structure s) {\n  structure* s_ptr = &s;\n  structure** s_ptr_ptr = &s_ptr;\n  taint_manipulated_with_indirections(s_ptr_ptr);\n  sink_int((**s_ptr_ptr).other);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 87, "end_line": 92}}
{"id": "field_taint_011", "source_file": "pulse/field_taint.c", "original_function_name": "test_taint_previously_unaccessed_field_bad", "anonymized_function_name": "test_taint_previously_unaccessed_field", "function_code": "void test_taint_previously_unaccessed_field(structure s) {\n  taint_structure(s);\n  sink_int(s.manipulated);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 2, "absolute_line": 96, "severity": "ERROR", "trace": "source of the taint here: value passed as argument `#0` to `taint_structure` with kind `Simple`,flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 94, "end_line": 97}}
{"id": "field_taint_012", "source_file": "pulse/field_taint.c", "original_function_name": "test_taint_logger_policy", "anonymized_function_name": "test_taint_logger_policy", "function_code": "void test_taint_logger_policy(structure s) {\n  taint_manipulated(s);\n  sink_log(s.manipulated);\n}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 2, "absolute_line": 101, "severity": "ERROR", "trace": "source of the taint here: field `manipulated` of value passed as argument `#0` to `taint_manipulated` with kind `Simple`,flows to this sink: value passed as argument `#0` to `sink_log` with kind `Logger`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 99, "end_line": 102}}
{"id": "fopen_001", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_getc_bad", "anonymized_function_name": "no_fopen_check_getc", "function_code": "void no_fopen_check_getc() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  i = getc(f);\n  printf(\"i =%i\\n\", i);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 15, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 11, "end_line": 18}}
{"id": "fopen_002", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_getc_ok", "anonymized_function_name": "fopen_check_getc", "function_code": "void fopen_check_getc() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    i = getc(f);\n    printf(\"i =%i\\n\", i);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 20, "end_line": 29}}
{"id": "fopen_003", "source_file": "pulse/fopen.c", "original_function_name": "fopen_no_fclose_bad", "anonymized_function_name": "fopen_no_fclose", "function_code": "void fopen_no_fclose() {\n  FILE* f;\n  int i;\n  f = fopen(\"some_file\", \"r\");\n  if (f) {\n    i = getc(f);\n    printf(\"i =%i\\n\", i);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_RESOURCE_LEAK", "line_offset": 5, "absolute_line": 36, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `fopen()` here,file descriptor becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "resource_leak", "start_line": 31, "end_line": 39}}
{"id": "fopen_004", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fgetc_bad", "anonymized_function_name": "no_fopen_check_fgetc", "function_code": "void no_fopen_check_fgetc() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  i = fgetc(f);\n  printf(\"i =%i\\n\", i);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 45, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 41, "end_line": 48}}
{"id": "fopen_005", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fgetc_ok", "anonymized_function_name": "fopen_check_fgetc", "function_code": "void fopen_check_fgetc() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    i = fgetc(f);\n    printf(\"i =%i\\n\", i);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 50, "end_line": 59}}
{"id": "fopen_006", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_ungetc_bad", "anonymized_function_name": "no_fopen_check_ungetc", "function_code": "void no_fopen_check_ungetc() {\n  FILE* f;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  int i = ungetc(10, f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 64, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 61, "end_line": 66}}
{"id": "fopen_007", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_ungetc_ok", "anonymized_function_name": "fopen_check_ungetc", "function_code": "void fopen_check_ungetc() {\n  FILE* f;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    int i = ungetc(10, f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 68, "end_line": 75}}
{"id": "fopen_008", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fputs_bad", "anonymized_function_name": "no_fopen_check_fputs", "function_code": "void no_fopen_check_fputs() {\n  FILE* f;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fputs(\"blablabla\", f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 80, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 77, "end_line": 82}}
{"id": "fopen_009", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fputs_ok", "anonymized_function_name": "fopen_check_fputs", "function_code": "void fopen_check_fputs() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fputs(\"blablabla\", f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 84, "end_line": 92}}
{"id": "fopen_010", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fputc_bad", "anonymized_function_name": "no_fopen_check_fputc", "function_code": "void no_fopen_check_fputc() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fputc(42, f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 98, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 94, "end_line": 100}}
{"id": "fopen_011", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fputc_ok", "anonymized_function_name": "fopen_check_fputc", "function_code": "void fopen_check_fputc() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fputc(42, f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 102, "end_line": 110}}
{"id": "fopen_012", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_putc_bad", "anonymized_function_name": "no_fopen_check_putc", "function_code": "void no_fopen_check_putc() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  putc(42, f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 116, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 112, "end_line": 118}}
{"id": "fopen_013", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_putc_ok", "anonymized_function_name": "fopen_check_putc", "function_code": "void fopen_check_putc() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    putc(42, f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 120, "end_line": 128}}
{"id": "fopen_014", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fseek_bad", "anonymized_function_name": "no_fopen_check_fseek", "function_code": "void no_fopen_check_fseek() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fseek(f, 7, SEEK_SET);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 134, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 130, "end_line": 136}}
{"id": "fopen_015", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fseek_ok", "anonymized_function_name": "fopen_check_fseek", "function_code": "void fopen_check_fseek() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fseek(f, 7, SEEK_SET);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 138, "end_line": 146}}
{"id": "fopen_016", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_ftell_bad", "anonymized_function_name": "no_fopen_check_ftell", "function_code": "void no_fopen_check_ftell() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  ftell(f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 152, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 148, "end_line": 154}}
{"id": "fopen_017", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_ftell_ok", "anonymized_function_name": "fopen_check_ftell", "function_code": "void fopen_check_ftell() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    ftell(f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 156, "end_line": 164}}
{"id": "fopen_018", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fgets_bad", "anonymized_function_name": "no_fopen_check_fgets", "function_code": "void no_fopen_check_fgets() {\n  FILE* f;\n  char str[60];\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fgets(str, 60, f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 171, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 166, "end_line": 173}}
{"id": "fopen_019", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fgets_ok", "anonymized_function_name": "fopen_check_fgets", "function_code": "void fopen_check_fgets() {\n  FILE* f;\n  char str[60];\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fgets(str, 60, f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 175, "end_line": 184}}
{"id": "fopen_020", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_rewind_bad", "anonymized_function_name": "no_fopen_check_rewind", "function_code": "void no_fopen_check_rewind() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  rewind(f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 190, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 186, "end_line": 192}}
{"id": "fopen_021", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_rewind_ok", "anonymized_function_name": "fopen_check_rewind", "function_code": "void fopen_check_rewind() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    rewind(f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 194, "end_line": 202}}
{"id": "fopen_022", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fileno_bad", "anonymized_function_name": "no_fopen_check_fileno", "function_code": "void no_fopen_check_fileno() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fileno(f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 208, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 204, "end_line": 210}}
{"id": "fopen_023", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fileno_ok", "anonymized_function_name": "fopen_check_fileno", "function_code": "void fopen_check_fileno() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fileno(f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 212, "end_line": 220}}
{"id": "fopen_024", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_clearerr_bad", "anonymized_function_name": "no_fopen_check_clearerr", "function_code": "void no_fopen_check_clearerr() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  clearerr(f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 226, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 222, "end_line": 228}}
{"id": "fopen_025", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_clearerr_ok", "anonymized_function_name": "fopen_check_clearerr", "function_code": "void fopen_check_clearerr() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    clearerr(f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 230, "end_line": 238}}
{"id": "fopen_026", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_ferror_bad", "anonymized_function_name": "no_fopen_check_ferror", "function_code": "void no_fopen_check_ferror() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  ferror(f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 244, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 240, "end_line": 246}}
{"id": "fopen_027", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_ferror_ok", "anonymized_function_name": "fopen_check_ferror", "function_code": "void fopen_check_ferror() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    ferror(f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 248, "end_line": 256}}
{"id": "fopen_028", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_feof_bad", "anonymized_function_name": "no_fopen_check_feof", "function_code": "void no_fopen_check_feof() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  feof(f);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 262, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 258, "end_line": 264}}
{"id": "fopen_029", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_feof_ok", "anonymized_function_name": "fopen_check_feof", "function_code": "void fopen_check_feof() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    feof(f);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 266, "end_line": 274}}
{"id": "fopen_030", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fprintf_bad", "anonymized_function_name": "no_fopen_check_fprintf", "function_code": "void no_fopen_check_fprintf() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fprintf(f, \"blablabla\\n\");\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 280, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 276, "end_line": 282}}
{"id": "fopen_031", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fprintf_ok", "anonymized_function_name": "fopen_check_fprintf", "function_code": "void fopen_check_fprintf() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fprintf(f, \"blablabla\\n\");\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 284, "end_line": 292}}
{"id": "fopen_032", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_vfprintf_bad", "anonymized_function_name": "no_fopen_check_vfprintf", "function_code": "void no_fopen_check_vfprintf() {\n  FILE* f;\n  va_list arg;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  vfprintf(f, \"blablabla\\n\", arg);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 297, "end_line": 304}}
{"id": "fopen_033", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_vfprintf_ok", "anonymized_function_name": "fopen_check_vfprintf", "function_code": "void fopen_check_vfprintf() {\n  FILE* f;\n  va_list arg;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    vfprintf(f, \"blablabla\\n\", arg);\n    fclose(f);\n  }\n} */\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 306, "end_line": 315}}
{"id": "fopen_034", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fgetpos_bad", "anonymized_function_name": "no_fopen_check_fgetpos", "function_code": "void no_fopen_check_fgetpos() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fgetpos(f, &position);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 322, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 317, "end_line": 324}}
{"id": "fopen_035", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fgetpos_ok", "anonymized_function_name": "fopen_check_fgetpos", "function_code": "void fopen_check_fgetpos() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fgetpos(f, &position);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 326, "end_line": 335}}
{"id": "fopen_036", "source_file": "pulse/fopen.c", "original_function_name": "no_fopen_check_fsetpos_bad", "anonymized_function_name": "no_fopen_check_fsetpos", "function_code": "void no_fopen_check_fsetpos() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fsetpos(f, &position);\n  fclose(f);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 342, "severity": "ERROR", "trace": "in call to `fopen` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 337, "end_line": 344}}
{"id": "fopen_037", "source_file": "pulse/fopen.c", "original_function_name": "fopen_check_fsetpos_ok", "anonymized_function_name": "fopen_check_fsetpos", "function_code": "void fopen_check_fsetpos() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fsetpos(f, &position);\n    fclose(f);\n  }\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 346, "end_line": 355}}
{"id": "fopen_038", "source_file": "pulse/fopen.c", "original_function_name": "file_operations_propagate_taint_bad", "anonymized_function_name": "file_operations_propagate_taint", "function_code": "void file_operations_propagate_taint() {\n  char* tainted = string_source();\n  FILE* file = fopen(tainted, \"r\");\n  if (!file) {\n    return;\n  }\n  char s[256];\n  char* t = fgets(s, 256, file);\n  sink_string(t);\n  sink_int(fgetc(file));\n  sink_int(getc(file));\n  sink_int(fileno(file)); // benign\n  fclose(file);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 8, "absolute_line": 370, "severity": "ERROR", "trace": "source of the taint here: value returned from `string_source` with kind `Simple`,in call to `fopen` (modelled),flows to this sink: value passed as argument `#0` to `sink_string` with kind `Simple`"}, {"bug_type": "TAINT_ERROR", "line_offset": 9, "absolute_line": 371, "severity": "ERROR", "trace": "source of the taint here: value returned from `string_source` with kind `Simple`,in call to `fopen` (modelled),in call to `fgetc` (modelled),flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}, {"bug_type": "TAINT_ERROR", "line_offset": 10, "absolute_line": 372, "severity": "ERROR", "trace": "source of the taint here: value returned from `string_source` with kind `Simple`,in call to `fopen` (modelled),in call to `getc` (modelled),flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 362, "end_line": 375}}
{"id": "fopen_039", "source_file": "pulse/fopen.c", "original_function_name": "fprintf_propagate_taint_bad", "anonymized_function_name": "fprintf_propagate_taint", "function_code": "void fprintf_propagate_taint() {\n  char* tainted = string_source();\n  FILE* file = fopen(\"some_file\", \"r\");\n  if (!file) {\n    return;\n  }\n  fprintf(file, \"%s\", tainted);\n  sink_int(getc(file));\n  fclose(file);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 6, "absolute_line": 383, "severity": "ERROR", "trace": "source of the taint here: value returned from `string_source` with kind `Simple`,flows to this sink: value passed as argument `#2` to `fprintf` with kind `Simple`"}, {"bug_type": "TAINT_ERROR", "line_offset": 7, "absolute_line": 384, "severity": "ERROR", "trace": "source of the taint here: value returned from `string_source` with kind `Simple`,in call to `fprintf` (modelled),in call to `getc` (modelled),flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 377, "end_line": 386}}
{"id": "fopen_040", "source_file": "pulse/fopen.c", "original_function_name": "fputs_propagate_taint_bad", "anonymized_function_name": "fputs_propagate_taint", "function_code": "void fputs_propagate_taint() {\n  char* tainted = string_source();\n  FILE* file = fopen(\"some_file\", \"r\");\n  if (!file) {\n    return;\n  }\n  fputs(tainted, file);\n  sink_int(getc(file));\n  fclose(file);\n}\n", "includes": ["#include <stdio.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 7, "absolute_line": 395, "severity": "ERROR", "trace": "source of the taint here: value returned from `string_source` with kind `Simple`,in call to `fputs` (modelled),in call to `getc` (modelled),flows to this sink: value passed as argument `#0` to `sink_int` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 388, "end_line": 397}}
{"id": "frontend_001", "source_file": "pulse/frontend.c", "original_function_name": "assign_implicit_cast_ok", "anonymized_function_name": "assign_implicit_cast", "function_code": "void assign_implicit_cast() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  uint16_t i = 1;\n  if (b) {\n    *b = true;\n    *b = !i;\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n", "includes": ["#include <stdbool.h>", "#include <stdint.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 12, "end_line": 24}}
{"id": "frontend_002", "source_file": "pulse/frontend.c", "original_function_name": "assign_implicit_cast_bad", "anonymized_function_name": "assign_implicit_cast", "function_code": "void assign_implicit_cast() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  uint16_t i = 0;\n  if (b) {\n    *b = false;\n    *b = !i;\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n", "includes": ["#include <stdbool.h>", "#include <stdint.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 8, "absolute_line": 34, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 26, "end_line": 38}}
{"id": "frontend_003", "source_file": "pulse/frontend.c", "original_function_name": "assign_paren_ok", "anonymized_function_name": "assign_paren", "function_code": "void assign_paren() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  int x = 42, y = 33;\n  if (b) {\n    *b = true;\n    *b = (x == y);\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n", "includes": ["#include <stdbool.h>", "#include <stdint.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 40, "end_line": 52}}
{"id": "frontend_004", "source_file": "pulse/frontend.c", "original_function_name": "assign_paren_bad", "anonymized_function_name": "assign_paren", "function_code": "void assign_paren() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  int x = 42, y = 42;\n  if (b) {\n    *b = false;\n    *b = (x == y);\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n", "includes": ["#include <stdbool.h>", "#include <stdint.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 8, "absolute_line": 62, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 54, "end_line": 66}}
{"id": "frontend_compound_literal_001", "source_file": "pulse/frontend_compound_literal.c", "original_function_name": "init_with_compound_literal_npe_bad", "anonymized_function_name": "init_with_compound_literal_npe", "function_code": "void init_with_compound_literal_npe() {\n  struct point p = (struct point){32, 52};\n  if (p.x == 32) {\n    int* pointer = NULL;\n    *pointer = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct point {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 19, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 15, "end_line": 21}}
{"id": "frontend_compound_literal_002", "source_file": "pulse/frontend_compound_literal.c", "original_function_name": "init_with_compound_literal_npe_good", "anonymized_function_name": "init_with_compound_literal_npe", "function_code": "void init_with_compound_literal_npe() {\n  struct point p = (struct point){32, 52};\n  if (p.x == 1) {\n    int* pointer = NULL;\n    *pointer = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct point {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 23, "end_line": 29}}
{"id": "frontend_struct_initlistexpr_001", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "return_5", "anonymized_function_name": "return_5", "function_code": "int return_5() { return 5; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 15, "end_line": 15}}
{"id": "frontend_struct_initlistexpr_002", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "init_Point", "anonymized_function_name": "init_Point", "function_code": "void init_Point() { struct Point p = {1, return_5() + 3}; }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int return_5() { return 5; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 17, "end_line": 17}}
{"id": "frontend_struct_initlistexpr_003", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "point_coords_set_correctly_npe_bad", "anonymized_function_name": "point_coords_set_correctly_npe", "function_code": "int point_coords_set_correctly_npe(Point* p) {\n  *p = (Point){4, 5};\n  int* pointer = NULL;\n  if (p->x == 4) {\n    return *pointer;\n  } else\n    return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 23, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 19, "end_line": 26}}
{"id": "frontend_struct_initlistexpr_004", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "point_coords_set_correctly_npe_good", "anonymized_function_name": "point_coords_set_correctly_npe", "function_code": "int point_coords_set_correctly_npe(Point* p) {\n  *p = (Point){4, 5};\n  int* pointer = NULL;\n  if (p->x == 1) {\n    return *pointer;\n  } else\n    return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 28, "end_line": 35}}
{"id": "frontend_struct_initlistexpr_005", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "field_set_correctly_npe_bad", "anonymized_function_name": "field_set_correctly_npe", "function_code": "int field_set_correctly_npe() {\n  struct Employee e = {12, 3000.50, 12, 12, 2010};\n  int* p = NULL;\n  if (e.ssn == 12) {\n    return *p;\n  } else\n    return 0;\n}\n", "includes": ["#include <stdlib.h>", "struct Employee {\n  int ssn;\n  float salary;\n  struct date {\n    int date;\n    int month;\n    int year;\n  } doj;\n} emp1;"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 51, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 47, "end_line": 54}}
{"id": "frontend_struct_initlistexpr_006", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "field_set_correctly_npe_good", "anonymized_function_name": "field_set_correctly_npe", "function_code": "int field_set_correctly_npe() {\n  struct Employee e = {12, 3000.50, 12, 12, 2010};\n  int* p = NULL;\n  if (e.ssn == 1) {\n    return *p;\n  } else\n    return 0;\n}\n", "includes": ["#include <stdlib.h>", "struct Employee {\n  int ssn;\n  float salary;\n  struct date {\n    int date;\n    int month;\n    int year;\n  } doj;\n} emp1;"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 56, "end_line": 63}}
{"id": "frontend_struct_initlistexpr_007", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "implicit_expr_set_correctly_npe_bad", "anonymized_function_name": "implicit_expr_set_correctly_npe", "function_code": "int implicit_expr_set_correctly_npe() {\n  rect imageDrawRect;\n  imageDrawRect = (rect){.size = 5};\n  int* p = NULL;\n  if (imageDrawRect.origin.x.a == 0) {\n    return *p;\n  } else\n    return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 87, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 82, "end_line": 90}}
{"id": "frontend_struct_initlistexpr_008", "source_file": "pulse/frontend_struct_initlistexpr.c", "original_function_name": "implicit_expr_set_correctly_npe_good", "anonymized_function_name": "implicit_expr_set_correctly_npe", "function_code": "int implicit_expr_set_correctly_npe() {\n  rect imageDrawRect;\n  imageDrawRect = (rect){.size = 5};\n  int* p = NULL;\n  if (imageDrawRect.origin.x.a == 1) {\n    return *p;\n  } else\n    return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 92, "end_line": 100}}
{"id": "funptr_001", "source_file": "pulse/funptr.c", "original_function_name": "do_nothing", "anonymized_function_name": "do_nothing", "function_code": "void do_nothing(int** _ptr) { return; }\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 9, "end_line": 9}}
{"id": "funptr_002", "source_file": "pulse/funptr.c", "original_function_name": "assign_NULL", "anonymized_function_name": "assign_NULL", "function_code": "void assign_NULL(int** ptr) { *ptr = NULL; }\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 11, "end_line": 11}}
{"id": "funptr_003", "source_file": "pulse/funptr.c", "original_function_name": "test_syntactic_specialization_bad", "anonymized_function_name": "test_syntactic_specialization", "function_code": "void test_syntactic_specialization(int* ptr) {\n  call_call_funptr(&assign_NULL, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 23, "severity": "ERROR", "trace": "in call to `call_call_funptr`,in call to `call_funptr`,in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,return from call to `call_funptr`,return from call to `call_call_funptr`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 21, "end_line": 24}}
{"id": "funptr_004", "source_file": "pulse/funptr.c", "original_function_name": "test_returned_funptr_specialization_bad", "anonymized_function_name": "test_returned_funptr_specialization", "function_code": "void test_returned_funptr_specialization(int* ptr) {\n  void (*funptr)(int**) = return_funptr();\n  call_call_funptr(funptr, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 33, "severity": "ERROR", "trace": "in call to `call_call_funptr`,in call to `call_funptr`,in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,return from call to `call_funptr`,return from call to `call_call_funptr`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 30, "end_line": 34}}
{"id": "funptr_005", "source_file": "pulse/funptr.c", "original_function_name": "funptr_if_bad", "anonymized_function_name": "funptr_if", "function_code": "int funptr_if() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 10, "absolute_line": 48, "severity": "ERROR", "trace": "in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 38, "end_line": 49}}
{"id": "funptr_006", "source_file": "pulse/funptr.c", "original_function_name": "funptr_if_good", "anonymized_function_name": "funptr_if", "function_code": "int funptr_if() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_NULL;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 51, "end_line": 62}}
{"id": "funptr_007", "source_file": "pulse/funptr.c", "original_function_name": "funptr_else_bad", "anonymized_function_name": "funptr_else", "function_code": "int funptr_else() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_NULL;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 10, "absolute_line": 74, "severity": "ERROR", "trace": "in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 64, "end_line": 75}}
{"id": "funptr_008", "source_file": "pulse/funptr.c", "original_function_name": "funptr_else_good", "anonymized_function_name": "funptr_else", "function_code": "int funptr_else() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 77, "end_line": 88}}
{"id": "funptr_009", "source_file": "pulse/funptr.c", "original_function_name": "funptr_conditional_call_bad", "anonymized_function_name": "funptr_conditional_call", "function_code": "int funptr_conditional_call(int x) {\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr);\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 9, "absolute_line": 99, "severity": "ERROR", "trace": "in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 90, "end_line": 100}}
{"id": "funptr_010", "source_file": "pulse/funptr.c", "original_function_name": "funptr_apply_funptr_with_intptrptr_specialized_bad", "anonymized_function_name": "funptr_apply_funptr_with_intptrptr_specialized", "function_code": "int funptr_apply_funptr_with_intptrptr_specialized() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr(funptr,\n                              &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 11, "absolute_line": 117, "severity": "ERROR", "trace": "in call to `apply_funptr_with_intptrptr`,in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,return from call to `apply_funptr_with_intptrptr`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 106, "end_line": 118}}
{"id": "funptr_011", "source_file": "pulse/funptr.c", "original_function_name": "funptr_apply_funptr_with_intptrptr_specialized_good", "anonymized_function_name": "funptr_apply_funptr_with_intptrptr_specialized", "function_code": "int funptr_apply_funptr_with_intptrptr_specialized() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_NULL;\n  }\n  apply_funptr_with_intptrptr(funptr,\n                              &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 120, "end_line": 132}}
{"id": "funptr_012", "source_file": "pulse/funptr.c", "original_function_name": "dereference_dereference_ptr", "anonymized_function_name": "dereference_dereference_ptr", "function_code": "void dereference_dereference_ptr(int** ptr) { int x = **ptr; }\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 145, "end_line": 145}}
{"id": "funptr_013", "source_file": "pulse/funptr.c", "original_function_name": "funptr_apply_funptr_with_intptrptr_and_after_specialized_bad", "anonymized_function_name": "funptr_apply_funptr_with_intptrptr_and_after_specialized", "function_code": "int funptr_apply_funptr_with_intptrptr_and_after_specialized() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  void (*after)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n    after = &dereference_dereference_ptr;\n  } else {\n    funptr = &do_nothing;\n    after = &do_nothing;\n  }\n  apply_funptr_with_intptrptr_and_after(\n      funptr,\n      after,\n      &ptr); // Calling funptr assigned in if branch. NPE when calling after\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 147, "end_line": 164}}
{"id": "funptr_014", "source_file": "pulse/funptr.c", "original_function_name": "funptr_apply_funptr_with_intptrptr_and_after_respecialized_bad", "anonymized_function_name": "funptr_apply_funptr_with_intptrptr_and_after_respecialized", "function_code": "int funptr_apply_funptr_with_intptrptr_and_after_respecialized() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr_and_after(\n      funptr,\n      &dereference_dereference_ptr,\n      &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 166, "end_line": 180}}
{"id": "funptr_015", "source_file": "pulse/funptr.c", "original_function_name": "funptr_conditionnaly_apply_funptr_with_intptrptr_unspecialized_bad", "anonymized_function_name": "funptr_conditionnaly_apply_funptr_with_intptrptr_unspecialized", "function_code": "int funptr_conditionnaly_apply_funptr_with_intptrptr_unspecialized() {\n  int x = 0;\n  int* ptr = NULL;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  conditionnaly_apply_funptr_with_intptrptr(\n      x, &ptr, funptr); // funptr is not called; function is not specialized\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 11, "absolute_line": 202, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,in call to `conditionnaly_apply_funptr_with_intptrptr`,is assigned to the null pointer,assigned,return from call to `conditionnaly_apply_funptr_with_intptrptr`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 191, "end_line": 203}}
{"id": "funptr_016", "source_file": "pulse/funptr.c", "original_function_name": "funptr_conditionnaly_apply_funptr_with_intptrptr_specialized_bad", "anonymized_function_name": "funptr_conditionnaly_apply_funptr_with_intptrptr_specialized", "function_code": "int funptr_conditionnaly_apply_funptr_with_intptrptr_specialized() {\n  int x = 1;\n  int* ptr = NULL;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  conditionnaly_apply_funptr_with_intptrptr(\n      x, &ptr, funptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 11, "absolute_line": 216, "severity": "ERROR", "trace": "in call to `conditionnaly_apply_funptr_with_intptrptr`,is assigned to the null pointer,assigned,return from call to `conditionnaly_apply_funptr_with_intptrptr`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 205, "end_line": 217}}
{"id": "funptr_017", "source_file": "pulse/funptr.c", "original_function_name": "apply_callback", "anonymized_function_name": "apply_callback", "function_code": "void apply_callback(callback_s* callback, int** ptr) { (*callback->f)(ptr); }\n", "includes": ["#include <stddef.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 226, "end_line": 226}}
{"id": "funptr_018", "source_file": "pulse/funptr.c", "original_function_name": "test_assign_NULL_callback_bad", "anonymized_function_name": "test_assign_NULL_callback", "function_code": "void test_assign_NULL_callback(int* ptr) {\n  callback_s callback = {.f = &assign_NULL};\n  apply_callback(&callback, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n", "includes": ["#include <stddef.h>"], "dependencies": ["void apply_callback(callback_s* callback, int** ptr) { (*callback->f)(ptr); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 231, "severity": "ERROR", "trace": "in call to `apply_callback`,in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,return from call to `apply_callback`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 228, "end_line": 232}}
{"id": "funptr_019", "source_file": "pulse/funptr.c", "original_function_name": "test_do_nothing_callback_good", "anonymized_function_name": "test_do_nothing_callback", "function_code": "void test_do_nothing_callback(int* ptr) {\n  callback_s callback = {.f = &do_nothing};\n  apply_callback(&callback, &ptr);\n  *ptr = 42; // latent NULL dereference here\n}\n", "includes": ["#include <stddef.h>"], "dependencies": ["void apply_callback(callback_s* callback, int** ptr) { (*callback->f)(ptr); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 234, "end_line": 238}}
{"id": "funptr_020", "source_file": "pulse/funptr.c", "original_function_name": "test_update_callback_bad", "anonymized_function_name": "test_update_callback", "function_code": "void test_update_callback(callback_s* callback, int* ptr) {\n  set_callback(callback, &assign_NULL);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n", "includes": ["#include <stddef.h>"], "dependencies": ["void apply_callback(callback_s* callback, int** ptr) { (*callback->f)(ptr); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 243, "severity": "ERROR", "trace": "in call to `apply_callback`,in call to `assign_NULL`,is assigned to the null pointer,assigned,return from call to `assign_NULL`,return from call to `apply_callback`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 240, "end_line": 244}}
{"id": "funptr_021", "source_file": "pulse/funptr.c", "original_function_name": "test_update_callback_good", "anonymized_function_name": "test_update_callback", "function_code": "void test_update_callback(callback_s* callback, int* ptr) {\n  set_callback(callback, &do_nothing);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // latent NULL dereference here\n}\n", "includes": ["#include <stddef.h>"], "dependencies": ["void apply_callback(callback_s* callback, int** ptr) { (*callback->f)(ptr); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 246, "end_line": 250}}
{"id": "getcwd_001", "source_file": "pulse/getcwd.c", "original_function_name": "getcwd_ok", "anonymized_function_name": "getcwd", "function_code": "char getcwd() {\n  char* cwd = getcwd(NULL, 0);\n  if (cwd != NULL) {\n    char result = cwd[0];\n    free(cwd);\n    return result;\n  }\n  char buf[BUFFER_SIZE];\n  cwd = getcwd(&buf, BUFFER_SIZE);\n  if (cwd != NULL) {\n    return cwd[0];\n  }\n  return 'a';\n}\n", "includes": ["#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 11, "end_line": 24}}
{"id": "getcwd_002", "source_file": "pulse/getcwd.c", "original_function_name": "getcwd_no_buf_no_check_bad", "anonymized_function_name": "getcwd_no_buf_no_check", "function_code": "char getcwd_no_buf_no_check() {\n  char* cwd = getcwd(NULL, 0);\n  char result = cwd[0];\n  free(cwd);\n  return result;\n}\n", "includes": ["#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 28, "severity": "ERROR", "trace": "in call to `getcwd` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 26, "end_line": 31}}
{"id": "getcwd_003", "source_file": "pulse/getcwd.c", "original_function_name": "getcwd_no_buf_no_free_bad", "anonymized_function_name": "getcwd_no_buf_no_free", "function_code": "char getcwd_no_buf_no_free() {\n  char* cwd = getcwd(NULL, 0);\n  if (cwd != NULL) {\n    return cwd[0];\n  }\n  return 'a';\n}\n", "includes": ["#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 3, "absolute_line": 36, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 33, "end_line": 39}}
{"id": "getcwd_004", "source_file": "pulse/getcwd.c", "original_function_name": "getcwd_no_check_bad", "anonymized_function_name": "getcwd_no_check", "function_code": "char getcwd_no_check() {\n  char buf[BUFFER_SIZE];\n  char* cwd = getcwd(&buf, BUFFER_SIZE);\n  return cwd[0];\n}\n", "includes": ["#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 44, "severity": "ERROR", "trace": "in call to `getcwd` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 41, "end_line": 45}}
{"id": "infinite_001", "source_file": "pulse/infinite.c", "original_function_name": "empty_function_ok", "anonymized_function_name": "empty_function", "function_code": "void empty_function() { return; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 9, "end_line": 9}}
{"id": "infinite_002", "source_file": "pulse/infinite.c", "original_function_name": "one_liner_ok", "anonymized_function_name": "one_liner", "function_code": "void one_liner(int x) { x++; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 12, "end_line": 12}}
{"id": "infinite_003", "source_file": "pulse/infinite.c", "original_function_name": "two_liner_ok", "anonymized_function_name": "two_liner", "function_code": "void two_liner(int x) {\n  x++;\n  return;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 15, "end_line": 18}}
{"id": "infinite_004", "source_file": "pulse/infinite.c", "original_function_name": "simple_goto_bad", "anonymized_function_name": "simple_goto", "function_code": "void simple_goto(int y) {\nre:\n  y++;\n  goto re;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 3, "absolute_line": 23, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 20, "end_line": 24}}
{"id": "infinite_005", "source_file": "pulse/infinite.c", "original_function_name": "simple_loop0_ok", "anonymized_function_name": "simple_loop0", "function_code": "void simple_loop0() {\n  int y = 0;\n  while (y < 100)\n    y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 27, "end_line": 31}}
{"id": "infinite_006", "source_file": "pulse/infinite.c", "original_function_name": "simple_loop0_bad", "anonymized_function_name": "simple_loop0", "function_code": "void simple_loop0() {\n  int y = 0;\n  int x = 0;\n  while (y < 100)\n    x++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 3, "absolute_line": 36, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 33, "end_line": 38}}
{"id": "infinite_007", "source_file": "pulse/infinite.c", "original_function_name": "simple_goto_ok", "anonymized_function_name": "simple_goto", "function_code": "void simple_goto(int y) {\n  y++;\n  goto end;\nend:\n  return;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 41, "end_line": 46}}
{"id": "infinite_008", "source_file": "pulse/infinite.c", "original_function_name": "entry_point_calling_bad", "anonymized_function_name": "entry_point_calling", "function_code": "void entry_point_calling() {\n  simple_loop0_bad();\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void simple_loop0_bad() {\n  int y = 0;\n  int x = 0;\n  while (y < 100)\n    x++;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 1, "absolute_line": 49, "severity": "WARNING", "trace": "when calling `simple_loop0_bad` here,original issue trace starts here,in loop"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 48, "end_line": 50}}
{"id": "infinite_009", "source_file": "pulse/infinite.c", "original_function_name": "conditional_goto0_bad", "anonymized_function_name": "conditional_goto0", "function_code": "void conditional_goto0(int y) {\nre:\n  if (y == 100)\n    goto re;\n  else\n    return;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 3, "absolute_line": 56, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 53, "end_line": 59}}
{"id": "infinite_010", "source_file": "pulse/infinite.c", "original_function_name": "conditional_goto0_ok", "anonymized_function_name": "conditional_goto0", "function_code": "void conditional_goto0(int y) {\nre:\n  if (y == 100) {\n    y++;\n    goto re;\n  } else\n    return;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 61, "end_line": 68}}
{"id": "infinite_011", "source_file": "pulse/infinite.c", "original_function_name": "fcall", "anonymized_function_name": "fcall", "function_code": "void fcall(int y) { y++; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 71, "end_line": 71}}
{"id": "infinite_012", "source_file": "pulse/infinite.c", "original_function_name": "loop_call_bad", "anonymized_function_name": "loop_call", "function_code": "void loop_call(int y) {\n  while (y == 100)\n    fcall(y);\n  return;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void fcall(int y) { y++; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 1, "absolute_line": 74, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 73, "end_line": 77}}
{"id": "infinite_013", "source_file": "pulse/infinite.c", "original_function_name": "fcall_by_ref", "anonymized_function_name": "fcall_by_ref", "function_code": "void fcall_by_ref(int* y) { (*y) = (*y) + 1; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 79, "end_line": 79}}
{"id": "infinite_014", "source_file": "pulse/infinite.c", "original_function_name": "loop_call_ok", "anonymized_function_name": "loop_call", "function_code": "void loop_call(int y) {\n  while (y == 100)\n    fcall_by_ref(&y);\n  return;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void fcall_by_ref(int* y) { (*y) = (*y) + 1; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 81, "end_line": 85}}
{"id": "infinite_015", "source_file": "pulse/infinite.c", "original_function_name": "twovars_goto_bad", "anonymized_function_name": "twovars_goto", "function_code": "void twovars_goto(int y) {\n  int z = y;\n  int x = 0;\nlabel:\n  x = 42;\n  goto label;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 5, "absolute_line": 92, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 87, "end_line": 93}}
{"id": "infinite_016", "source_file": "pulse/infinite.c", "original_function_name": "loop_pointer_ok", "anonymized_function_name": "loop_pointer", "function_code": "void loop_pointer(int* x, int y) {\n  int* z = x;\n  // int y = 1;\n  if (x != &y)\n    while (y < 100) {\n      y++;\n      (*z)--;\n    }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 96, "end_line": 104}}
{"id": "infinite_017", "source_file": "pulse/infinite.c", "original_function_name": "loop_pointer_bad", "anonymized_function_name": "loop_pointer", "function_code": "void loop_pointer(int* x, int y) {\n  int* z = x;\n  // int y = 1;\n  if (x == &y)\n    while (y < 100) {\n      y++;\n      (*z)--;\n    }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 4, "absolute_line": 111, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 107, "end_line": 115}}
{"id": "infinite_018", "source_file": "pulse/infinite.c", "original_function_name": "var_goto_ok", "anonymized_function_name": "var_goto", "function_code": "void var_goto(int y) {\n  int x = 42;\n  goto end;\n  x++;\nend:\n  return;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 118, "end_line": 124}}
{"id": "infinite_019", "source_file": "pulse/infinite.c", "original_function_name": "loop_conditional_bad", "anonymized_function_name": "loop_conditional", "function_code": "void loop_conditional(int y) {\n  int x = 0;\n  while (y < 100)\n    if (y < 50)\n      x++;\n    else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 129, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 127, "end_line": 134}}
{"id": "infinite_020", "source_file": "pulse/infinite.c", "original_function_name": "loop_conditional_ok", "anonymized_function_name": "loop_conditional", "function_code": "void loop_conditional(int y) {\n  int x = 0;\n  while (y < 100)\n    if (y < 50) {\n      x++;\n      y = 50;\n    } else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 136, "end_line": 144}}
{"id": "infinite_021", "source_file": "pulse/infinite.c", "original_function_name": "nested_external_bad", "anonymized_function_name": "nested_external", "function_code": "void nested_external(int y) {\n  int x = 0;\n  while (y < 100) {\n    while (x < 3) {\n      x++;\n    }\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 162, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 160, "end_line": 167}}
{"id": "infinite_022", "source_file": "pulse/infinite.c", "original_function_name": "nested_external_ok", "anonymized_function_name": "nested_external", "function_code": "void nested_external(int y) {\n  int x = 0;\n  while (y < 100) {\n    while (x < 2) {\n      x++;\n    }\n    y++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 169, "end_line": 177}}
{"id": "infinite_023", "source_file": "pulse/infinite.c", "original_function_name": "nested_loop_cond_ok", "anonymized_function_name": "nested_loop_cond", "function_code": "void nested_loop_cond(int y) {\n  int x = 42;\n  while (y < 100) {\n    while (x <= 100) {\n      if (x == 50)\n        x = 60;\n      else\n        x++;\n    }\n    y++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 179, "end_line": 190}}
{"id": "infinite_024", "source_file": "pulse/infinite.c", "original_function_name": "simple_loop_bad", "anonymized_function_name": "simple_loop", "function_code": "void simple_loop(int x) {\n  int y = 1;\n  while (x != 3)\n    y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 195, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 193, "end_line": 197}}
{"id": "infinite_025", "source_file": "pulse/infinite.c", "original_function_name": "simple_loop_ok", "anonymized_function_name": "simple_loop", "function_code": "void simple_loop(int x) {\n  int y = 1;\n  while (y != 3)\n    y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 199, "end_line": 203}}
{"id": "infinite_026", "source_file": "pulse/infinite.c", "original_function_name": "loop_alternating_bad", "anonymized_function_name": "loop_alternating", "function_code": "void loop_alternating(int y, int x) {\n  int turn = 0;\n  while (x < 100) {\n    if (turn)\n      x++;\n    else\n      x--;\n    turn = (turn ? 0 : 1);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 207, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 205, "end_line": 214}}
{"id": "infinite_027", "source_file": "pulse/infinite.c", "original_function_name": "loop_alternating_ok", "anonymized_function_name": "loop_alternating", "function_code": "void loop_alternating(int y, int x) {\n  int turn = 0;\n  while (x < 100) {\n    if (turn)\n      x++;\n    else\n      x = x + 2;\n    turn = (turn ? 0 : 1);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 216, "end_line": 225}}
{"id": "infinite_028", "source_file": "pulse/infinite.c", "original_function_name": "inner_loop_bad", "anonymized_function_name": "inner_loop", "function_code": "void inner_loop(int y, int x) {\n  while (y < 100) {\n    while (x == 0)\n      y++;\n    y++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 229, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 227, "end_line": 233}}
{"id": "infinite_029", "source_file": "pulse/infinite.c", "original_function_name": "inner_loop_ok", "anonymized_function_name": "inner_loop", "function_code": "void inner_loop(int y, int x) {\n  while (y < 100) {\n    while (x == 0) {\n      y++;\n      x++;\n    }\n    y++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 235, "end_line": 243}}
{"id": "infinite_030", "source_file": "pulse/infinite.c", "original_function_name": "simple_dowhile_ok", "anonymized_function_name": "simple_dowhile", "function_code": "void simple_dowhile(int y, int x) {\n  do {\n    y++;\n    x++;\n  } while (0);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 245, "end_line": 250}}
{"id": "infinite_031", "source_file": "pulse/infinite.c", "original_function_name": "simple_dowhile_bad", "anonymized_function_name": "simple_dowhile", "function_code": "void simple_dowhile(int y, int x) {\n  do {\n    x++;\n  } while (y > 0);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 1, "absolute_line": 253, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 252, "end_line": 256}}
{"id": "infinite_032", "source_file": "pulse/infinite.c", "original_function_name": "conditional_goto_ok", "anonymized_function_name": "conditional_goto", "function_code": "int conditional_goto(int x, int y) {\nre:\n  x++;\n  if (0) {\n    int z1 = x * 2;\n    goto re;\n    return (z1);\n  } else {\n    int z2 = x + y;\n    return z2;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 258, "end_line": 269}}
{"id": "infinite_033", "source_file": "pulse/infinite.c", "original_function_name": "conditional_goto_bad", "anonymized_function_name": "conditional_goto", "function_code": "int conditional_goto(int x, int y) {\nre:\n  x++;\n  if (y) {\n    int z1 = x * 2;\n    goto re;\n    return (z1);\n  } else {\n    int z2 = x + y;\n    return z2;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 5, "absolute_line": 276, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 271, "end_line": 282}}
{"id": "infinite_034", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_break_ok", "anonymized_function_name": "loop_with_break", "function_code": "void loop_with_break(int y) {\n  y = 0;\n  while (y < 100)\n    if (y == 50)\n      break;\n    else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 303, "end_line": 310}}
{"id": "infinite_035", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_break_var1_ok", "anonymized_function_name": "loop_with_break_var1", "function_code": "void loop_with_break_var1(int y) {\n  y = 0;\n  while (y < 100)\n    if (y == 50) {\n      y--;\n      break;\n    } else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 313, "end_line": 321}}
{"id": "infinite_036", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_break_var2_ok", "anonymized_function_name": "loop_with_break_var2", "function_code": "void loop_with_break_var2(int y) {\n  while (y < 100)\n    if (y == 50) {\n      y--;\n      break;\n    } else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 324, "end_line": 331}}
{"id": "infinite_037", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_break_var3_ok", "anonymized_function_name": "loop_with_break_var3", "function_code": "void loop_with_break_var3(int y) {\n  while (y < 100)\n    if (y == 50)\n      break;\n    else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 334, "end_line": 340}}
{"id": "infinite_038", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_return_ok", "anonymized_function_name": "loop_with_return", "function_code": "void loop_with_return(int y) {\n  while (y < 100)\n    if (y == 50) {\n      y--;\n      return;\n    } else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 343, "end_line": 350}}
{"id": "infinite_039", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_return_ok_var1", "anonymized_function_name": "loop_with_return_ok_var1", "function_code": "void loop_with_return_ok_var1(int y) {\n  while (y < 100)\n    if (y == 50)\n      return;\n    else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 353, "end_line": 359}}
{"id": "infinite_040", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_return_var2_ok", "anonymized_function_name": "loop_with_return_var2", "function_code": "void loop_with_return_var2(int y) {\n  y = 0;\n  while (y < 100)\n    if (y == 50) {\n      y--;\n      return;\n    } else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 362, "end_line": 370}}
{"id": "infinite_041", "source_file": "pulse/infinite.c", "original_function_name": "loop_with_return_var3_ok", "anonymized_function_name": "loop_with_return_var3", "function_code": "void loop_with_return_var3(int y) {\n  y = 0;\n  while (y < 100)\n    if (y == 50)\n      return;\n    else\n      y++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 373, "end_line": 380}}
{"id": "infinite_042", "source_file": "pulse/infinite.c", "original_function_name": "while_even_bad", "anonymized_function_name": "while_even", "function_code": "void while_even() {\n  int i = 0;\n  while (i % 2 == 0)\n    i = i + 2;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 390, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 388, "end_line": 392}}
{"id": "infinite_043", "source_file": "pulse/infinite.c", "original_function_name": "incr_if_non_zero", "anonymized_function_name": "incr_if_non_zero", "function_code": "int incr_if_non_zero(int x, int y) {\n  if (y == 0)\n    return x;\n  else\n    return x + 1;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 394, "end_line": 399}}
{"id": "infinite_044", "source_file": "pulse/infinite.c", "original_function_name": "incr_with_call_bad", "anonymized_function_name": "incr_with_call", "function_code": "void incr_with_call(int y) {\n  int i = 0;\n  while (i < 100)\n    i = incr_if_non_zero(i, y);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int incr_if_non_zero(int x, int y) {\n  if (y == 0)\n    return x;\n  else\n    return x + 1;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 403, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 401, "end_line": 405}}
{"id": "infinite_045", "source_file": "pulse/infinite.c", "original_function_name": "incr_if_geq_zero", "anonymized_function_name": "incr_if_geq_zero", "function_code": "int incr_if_geq_zero(int x) {\n  if (x < 0)\n    return x;\n  else\n    return x + 1;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 407, "end_line": 412}}
{"id": "infinite_046", "source_file": "pulse/infinite.c", "original_function_name": "incr_with_call_ok", "anonymized_function_name": "incr_with_call", "function_code": "void incr_with_call() {\n  int i = 0;\n  while (i < 100)\n    i = incr_if_geq_zero(i);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int incr_if_geq_zero(int x) {\n  if (x < 0)\n    return x;\n  else\n    return x + 1;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 414, "end_line": 418}}
{"id": "infinite_047", "source_file": "pulse/infinite.c", "original_function_name": "loop_repeated_ok", "anonymized_function_name": "loop_repeated", "function_code": "int loop_repeated(int i) {\n  int val = 0;\n  for (i = 0; i < 3; i++)\n    val++;\n  for (i = 0; i < 3; i++)\n    val++;\n  return (val);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 420, "end_line": 427}}
{"id": "infinite_048", "source_file": "pulse/infinite.c", "original_function_name": "two_ints_loop_cook06_ok", "anonymized_function_name": "two_ints_loop_cook06", "function_code": "void two_ints_loop_cook06(int x, int y) {\n  if (y >= 1)\n    while (x >= 0)\n      x = x + y;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 482, "end_line": 486}}
{"id": "infinite_049", "source_file": "pulse/infinite.c", "original_function_name": "Ack", "anonymized_function_name": "Ack", "function_code": "int Ack(int x, int y) {\n  if (x > 0) {\n    int n;\n    if (y > 0) {\n      y--;\n      n = Ack(x, y);\n    } else {\n      n = 1;\n    }\n    x--;\n    return Ack(x, n);\n  } else {\n    return y + 1;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MUTUAL_RECURSION_CYCLE", "line_offset": 5, "absolute_line": 494, "severity": "WARNING", "trace": "`Ack` makes a recursive call to `Ack`"}, {"bug_type": "MUTUAL_RECURSION_CYCLE", "line_offset": 10, "absolute_line": 499, "severity": "WARNING", "trace": "`Ack` makes a recursive call to `Ack`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 489, "end_line": 503}}
{"id": "infinite_050", "source_file": "pulse/infinite.c", "original_function_name": "nondet", "anonymized_function_name": "nondet", "function_code": "int nondet() { return (rand()); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 508, "end_line": 508}}
{"id": "infinite_051", "source_file": "pulse/infinite.c", "original_function_name": "benchmark_nondet_cook06_ok", "anonymized_function_name": "benchmark_nondet_cook06", "function_code": "int benchmark_nondet_cook06() {\n  int x = nondet();\n  int y = nondet();\n\n  int* p = &y;\n  int* q = &x;\n  int b = 1;\n\n  while (x < 100 && 100 < y && b) {\n    if (p == q) {\n      int k = Ack(nondet(), nondet());\n      (*p)++;\n      while ((k--) > 100) {\n        if (nondet()) {\n          p = &y;\n        }\n        if (nondet()) {\n          p = &x;\n        }\n        if (!b) {\n          k++;\n        }\n      }\n    } else {\n      (*q)--;\n      (*p)--;\n      if (nondet()) {\n        p = &y;\n      }\n      if (nondet()) {\n        p = &x;\n      }\n    }\n    b = nondet();\n  }\n  return (0);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int Ack(int x, int y) {\n  if (x > 0) {\n    int n;\n    if (y > 0) {\n      y--;\n      n = Ack(x, y);\n    } else {\n      n = 1;\n    }\n    x--;\n    return Ack(x, n);\n  } else {\n    return y + 1;\n  }\n}\n", "int nondet() { return (rand()); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 509, "end_line": 545}}
{"id": "infinite_052", "source_file": "pulse/infinite.c", "original_function_name": "benchmark_cook06_ok", "anonymized_function_name": "benchmark_cook06", "function_code": "void benchmark_cook06() {\n  int x = nondet(), y = nondet(), z = nondet();\n  if (y > 0) {\n    do {\n      if (npc == 5) {\n        if (!((y < z && z <= nz) || (x < y && x >= nx) || 0))\n          ;\n      }\n      if (npc == 0) {\n        if (nondet()) {\n          nx = x;\n          ny = y;\n          nz = z;\n          npc = 5;\n        }\n      }\n      if (nondet()) {\n        x = x + y;\n      } else {\n        z = x - y;\n      }\n    } while (x < y && y < z);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int nondet() { return (rand()); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 553, "end_line": 576}}
{"id": "infinite_053", "source_file": "pulse/infinite.c", "original_function_name": "benchmark_simple_cook06_ok", "anonymized_function_name": "benchmark_simple_cook06", "function_code": "void benchmark_simple_cook06() {\n  int x = nondet(), y = nondet(), z = nondet();\n  if (y > 0) {\n    do {\n      if (nondet()) {\n        x = x + y;\n      } else {\n        z = x - y;\n      }\n    } while (x < y && y < z);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int nondet() { return (rand()); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 582, "end_line": 593}}
{"id": "infinite_054", "source_file": "pulse/infinite.c", "original_function_name": "nondet_loop_bad", "anonymized_function_name": "nondet_loop", "function_code": "void nondet_loop(int z) {\n  int x = 1;\n  while (x < z)\n    if (nondet())\n      x++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int nondet() { return (rand()); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 600, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 598, "end_line": 603}}
{"id": "infinite_055", "source_file": "pulse/infinite.c", "original_function_name": "hensel_tacas22_bad", "anonymized_function_name": "hensel_tacas22", "function_code": "void hensel_tacas22(int x, int y) {\n  y = 0;\n  while (x > 0) {\n    x--;\n    y++;\n  }\n  while (y > 1)\n    y = y;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 6, "absolute_line": 614, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 608, "end_line": 616}}
{"id": "infinite_056", "source_file": "pulse/infinite.c", "original_function_name": "foo", "anonymized_function_name": "foo", "function_code": "void foo(int* x) { (*x)--; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 620, "end_line": 620}}
{"id": "infinite_057", "source_file": "pulse/infinite.c", "original_function_name": "interproc_terminating_harris10_ok", "anonymized_function_name": "interproc_terminating_harris10", "function_code": "void interproc_terminating_harris10(int x) {\n  while (x > 0)\n    foo(&x);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void foo(int* x) { (*x)--; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 624, "end_line": 627}}
{"id": "infinite_058", "source_file": "pulse/infinite.c", "original_function_name": "interproc_terminating_harris10_cond_ok", "anonymized_function_name": "interproc_terminating_harris10_cond", "function_code": "void interproc_terminating_harris10_cond(int x) {\n  while (x > 0) {\n    if (nondet())\n      foo(&x);\n    else\n      foo(&x);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int nondet() { return (rand()); }\n", "void foo(int* x) { (*x)--; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 631, "end_line": 638}}
{"id": "infinite_059", "source_file": "pulse/infinite.c", "original_function_name": "loop_non_terminating_harris10_bad", "anonymized_function_name": "loop_non_terminating_harris10", "function_code": "void loop_non_terminating_harris10(int x, int d, int z) {\n  d = 0;\n  z = 0;\n  while (x > 0) {\n    z++;\n    x = x - d;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 3, "absolute_line": 648, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 645, "end_line": 652}}
{"id": "infinite_060", "source_file": "pulse/infinite.c", "original_function_name": "nondet_nonterminate_chen14_bad", "anonymized_function_name": "nondet_nonterminate_chen14", "function_code": "void nondet_nonterminate_chen14(int k, int i) {\n  if (k >= 0)\n    ;\n  else\n    i = -1;\n  while (i >= 0)\n    i = nondet();\n  i = 2;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int nondet() { return (rand()); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 5, "absolute_line": 666, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 661, "end_line": 669}}
{"id": "infinite_061", "source_file": "pulse/infinite.c", "original_function_name": "nestedloop2_chen14_ok", "anonymized_function_name": "nestedloop2_chen14", "function_code": "void nestedloop2_chen14(int k, int j) {\n  while (k >= 0) {\n    k++;\n    j = k;\n    while (j >= 1)\n      j--;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 675, "end_line": 682}}
{"id": "infinite_062", "source_file": "pulse/infinite.c", "original_function_name": "array_iter_ok", "anonymized_function_name": "array_iter", "function_code": "void array_iter(int array[]) {\n  unsigned int i = 0;\n  while (array[i] != 0) {\n    array[i] = 42;\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 698, "end_line": 704}}
{"id": "infinite_063", "source_file": "pulse/infinite.c", "original_function_name": "array2_iter_ok", "anonymized_function_name": "array2_iter", "function_code": "void array2_iter(int array1[], int array2[]) {\n  unsigned int i = 0;\n  while (array1[i] != 0) {\n    array2[i] = 42;\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 707, "end_line": 713}}
{"id": "infinite_064", "source_file": "pulse/infinite.c", "original_function_name": "array_iter_bad", "anonymized_function_name": "array_iter", "function_code": "void array_iter(int array[], int len) {\n  int i = 0;\n  while (i < len) {\n    array[i] = 42;\n    if (i > 10)\n      i = 0;\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 717, "end_line": 725}}
{"id": "infinite_065", "source_file": "pulse/infinite.c", "original_function_name": "iterate_arraysize_ok", "anonymized_function_name": "iterate_arraysize", "function_code": "void iterate_arraysize(int array[256]) {\n  unsigned int i = 0;\n  while (i < (sizeof(*array) / sizeof(array[0]))) {\n    array[i] = i;\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 729, "end_line": 735}}
{"id": "infinite_066", "source_file": "pulse/infinite.c", "original_function_name": "iterate_bitmask_ok", "anonymized_function_name": "iterate_bitmask", "function_code": "void iterate_bitmask(int array[256], int len) {\n  unsigned int i = 0;\n  while (i < len) {\n    array[i] = (i & (~7));\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 739, "end_line": 745}}
{"id": "infinite_067", "source_file": "pulse/infinite.c", "original_function_name": "iterate_bitmask2_ok", "anonymized_function_name": "iterate_bitmask2", "function_code": "void iterate_bitmask2(int array[256], int len) {\n  unsigned int i = 0;\n  unsigned int j = 0;\n  while (i < len) {\n    j = (i & (~7));\n    array[j] = i;\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 749, "end_line": 757}}
{"id": "infinite_068", "source_file": "pulse/infinite.c", "original_function_name": "iterate_bitmask_bad", "anonymized_function_name": "iterate_bitmask", "function_code": "void iterate_bitmask(int array[256], unsigned int len) {\n  unsigned int i = 0;\n  while (i < len) {\n    i = (i & (~7));\n    array[i] = i;\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 763, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 761, "end_line": 768}}
{"id": "infinite_069", "source_file": "pulse/infinite.c", "original_function_name": "bitshift_right_loop_ok", "anonymized_function_name": "bitshift_right_loop", "function_code": "void bitshift_right_loop(int i) {\n  while (i)\n    i = i >> 1;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 771, "end_line": 774}}
{"id": "infinite_070", "source_file": "pulse/infinite.c", "original_function_name": "bitshift_left_loop_ok", "anonymized_function_name": "bitshift_left_loop", "function_code": "void bitshift_left_loop(int i) {\n  while (i)\n    i = i << 1;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 777, "end_line": 780}}
{"id": "infinite_071", "source_file": "pulse/infinite.c", "original_function_name": "bitshift_loop_ok", "anonymized_function_name": "bitshift_loop", "function_code": "void bitshift_loop(unsigned int i) {\n  while (i % 2)\n    i = (i << 1);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 783, "end_line": 786}}
{"id": "infinite_072", "source_file": "pulse/infinite.c", "original_function_name": "iterate_bitshift1_ok", "anonymized_function_name": "iterate_bitshift1", "function_code": "void iterate_bitshift1(int array[256], int len) {\n  unsigned int i = 1;\n  while (i < len) {\n    array[i] = i;\n    i = i << 1;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 801, "end_line": 807}}
{"id": "infinite_073", "source_file": "pulse/infinite.c", "original_function_name": "iterate_bitshift2_ok", "anonymized_function_name": "iterate_bitshift2", "function_code": "void iterate_bitshift2(int array[256], unsigned char i) {\n  while (i != 0) {\n    array[i] = i;\n    i = i >> 1;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 811, "end_line": 816}}
{"id": "infinite_074", "source_file": "pulse/infinite.c", "original_function_name": "iterate_intoverflow_ok", "anonymized_function_name": "iterate_intoverflow", "function_code": "void iterate_intoverflow(int len) {\n  unsigned int i = 0xFFFFFFFF;\n  while (i != 0)\n    i++;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 819, "end_line": 823}}
{"id": "infinite_075", "source_file": "pulse/infinite.c", "original_function_name": "iterate_crc_ok", "anonymized_function_name": "iterate_crc", "function_code": "void iterate_crc() {\n  unsigned int k;\n  unsigned long crc0 = 0xFFFFFFFF;\n\n  for (k = 1; k < W; k++) {\n    crc0++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 843, "end_line": 850}}
{"id": "infinite_076", "source_file": "pulse/infinite.c", "original_function_name": "png_palette_ok", "anonymized_function_name": "png_palette", "function_code": "void png_palette(int val) {\n  int num;\n  int i;\n  int p = 0;\n\n  if (val == 0)\n    num = 1;\n  else\n    num = 10;\n\n  for (i = 0; i < num; i++)\n    p += val;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 855, "end_line": 867}}
{"id": "infinite_077", "source_file": "pulse/infinite.c", "original_function_name": "simple_loop_equal_bad", "anonymized_function_name": "simple_loop_equal", "function_code": "void simple_loop_equal() {\n  int x = 42;\n  while (x == x)\n    x = x + 1;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 873, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 871, "end_line": 875}}
{"id": "infinite_078", "source_file": "pulse/infinite.c", "original_function_name": "compute_increment", "anonymized_function_name": "compute_increment", "function_code": "int compute_increment(int k) { return (k % 2 ? 1 : 0); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 878, "end_line": 878}}
{"id": "infinite_079", "source_file": "pulse/infinite.c", "original_function_name": "loop_fcall_add_inductive_bad", "anonymized_function_name": "loop_fcall_add_inductive", "function_code": "void loop_fcall_add_inductive() {\n  int i;\n  int incr;\n  for (i = 0; i < 10; i += incr)\n    incr = compute_increment(i);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int compute_increment(int k) { return (k % 2 ? 1 : 0); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 3, "absolute_line": 883, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 880, "end_line": 885}}
{"id": "infinite_080", "source_file": "pulse/infinite.c", "original_function_name": "allocate_all_in_array_ok", "anonymized_function_name": "allocate_all_in_array", "function_code": "void allocate_all_in_array(int* array[]) {\n  for (int i = 0; i < 2; i++) {\n    array[i] = malloc(sizeof(int));\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 889, "end_line": 893}}
{"id": "infinite_081", "source_file": "pulse/infinite.c", "original_function_name": "goto_in_loop_without_eqtest_bad", "anonymized_function_name": "goto_in_loop_without_eqtest", "function_code": "void goto_in_loop_without_eqtest() {\n  int i = 0;\n  int j = 0;\n  while (i < 10) {\n  retry:\n    j++;\n    goto retry;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 6, "absolute_line": 914, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 908, "end_line": 916}}
{"id": "infinite_082", "source_file": "pulse/infinite.c", "original_function_name": "goto_cross_loop_bad", "anonymized_function_name": "goto_cross_loop", "function_code": "void goto_cross_loop() {\n  int i = 0;\n\nretry:\n  while (i < 10) {\n    if (i == 5)\n      goto retry;\n    i++;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 6, "absolute_line": 925, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 919, "end_line": 928}}
{"id": "infinite_083", "source_file": "pulse/infinite.c", "original_function_name": "constant_loop_ok", "anonymized_function_name": "constant_loop", "function_code": "int constant_loop(int i, int j) {\n  for (i = 0; i < defined_const; i++)\n    j++;\n  return (j);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 932, "end_line": 936}}
{"id": "initlistexpr_001", "source_file": "pulse/initlistexpr.c", "original_function_name": "array_init_bad", "anonymized_function_name": "array_init", "function_code": "int array_init() {\n  int t[2][3][2] = {{{1, 1}, {2, 2}, {3, 3}}, {{4, 4}, {5, 5}, {1, 0}}};\n  if (t[0][1][0] == 2 && t[1][2][1] == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 14, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 10, "end_line": 16}}
{"id": "initlistexpr_002", "source_file": "pulse/initlistexpr.c", "original_function_name": "array_init_ok", "anonymized_function_name": "array_init", "function_code": "int array_init() {\n  int t[2][3][2] = {{{1, 1}, {2, 2}, {3, 3}}, {{4, 4}, {5, 5}, {1, 0}}};\n  if (t[0][1][0] != 2 || t[1][2][1] != 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 18, "end_line": 24}}
{"id": "integers_001", "source_file": "pulse/integers.c", "original_function_name": "even_cannot_be_odd_local_ok", "anonymized_function_name": "even_cannot_be_odd_local", "function_code": "void even_cannot_be_odd_local(int y) {\n  int x = y;\n  if (x + x == 5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 10, "end_line": 16}}
{"id": "integers_002", "source_file": "pulse/integers.c", "original_function_name": "even_cannot_be_odd_parameter_ok", "anonymized_function_name": "even_cannot_be_odd_parameter", "function_code": "void even_cannot_be_odd_parameter(int x) {\n  if (x + x == 5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 18, "end_line": 23}}
{"id": "integers_003", "source_file": "pulse/integers.c", "original_function_name": "even_cannot_be_odd_float_conv_ok", "anonymized_function_name": "even_cannot_be_odd_float_conv", "function_code": "void even_cannot_be_odd_float_conv() {\n  int x = random();\n  if (x + x == (int)5.5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 25, "end_line": 31}}
{"id": "integers_004", "source_file": "pulse/integers.c", "original_function_name": "float_div_bad", "anonymized_function_name": "float_div", "function_code": "void float_div() {\n  float y = 5.0 / 2.0;\n  if (y != 2.0) { // always true\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 70, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 66, "end_line": 72}}
{"id": "integers_005", "source_file": "pulse/integers.c", "original_function_name": "float_comparison_bad", "anonymized_function_name": "float_comparison", "function_code": "void float_comparison(float f) {\n  if (2 + f < 2.2) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 77, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 74, "end_line": 79}}
{"id": "interprocedural_001", "source_file": "pulse/interprocedural.c", "original_function_name": "conditional_free", "anonymized_function_name": "conditional_free", "function_code": "void conditional_free(int x, int* y) {\n  if (x > 5) {\n    free(y);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 9, "end_line": 13}}
{"id": "interprocedural_002", "source_file": "pulse/interprocedural.c", "original_function_name": "conditional_free_then_use_latent", "anonymized_function_name": "conditional_free_then_use", "function_code": "void conditional_free_then_use(int x) {\n  int* y = (int*)malloc(sizeof(int));\n  conditional_free(x, y);\n  if (y != NULL) {\n    // arguably we should report here since the code is bad, but the current\n    // heuristic classifies this as latent\n    *y = 1;\n  }\n  // avoid memory leak\n  if (x <= 5) {\n    free(y);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void conditional_free(int x, int* y) {\n  if (x > 5) {\n    free(y);\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "USE_AFTER_FREE_LATENT", "line_offset": 6, "absolute_line": 21, "severity": "ERROR", "trace": "invalidation part of the trace starts here,allocated by call to `malloc` (modelled),assigned,when calling `conditional_free` here,parameter `y` of conditional_free,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,allocated by call to `malloc` (modelled),assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 15, "end_line": 27}}
{"id": "interprocedural_003", "source_file": "pulse/interprocedural.c", "original_function_name": "call_conditional_free_then_use_bad", "anonymized_function_name": "call_conditional_free_then_use", "function_code": "void call_conditional_free_then_use() {\n  conditional_free_then_use_latent(7);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void conditional_free_then_use_latent(int x) {\n  int* y = (int*)malloc(sizeof(int));\n  conditional_free(x, y);\n  if (y != NULL) {\n    // arguably we should report here since the code is bad, but the current\n    // heuristic classifies this as latent\n    *y = 1;\n  }\n  // avoid memory leak\n  if (x <= 5) {\n    free(y);\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "USE_AFTER_FREE", "line_offset": 1, "absolute_line": 30, "severity": "ERROR", "trace": "invalidation part of the trace starts here,allocated by call to `malloc` (modelled),assigned,when calling `conditional_free` here,parameter `y` of conditional_free,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,when calling `conditional_free_then_use_latent` here,allocated by call to `malloc` (modelled),assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "use_after_free", "start_line": 29, "end_line": 31}}
{"id": "interprocedural_004", "source_file": "pulse/interprocedural.c", "original_function_name": "test_modified_value_then_error_bad", "anonymized_function_name": "test_modified_value_then_error", "function_code": "void test_modified_value_then_error(int* x) {\n  *x = random();\n  if (*x == 5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 39, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 35, "end_line": 41}}
{"id": "interprocedural_005", "source_file": "pulse/interprocedural.c", "original_function_name": "latent_dereference", "anonymized_function_name": "latent_dereference", "function_code": "void latent_dereference(int a, int* p) {\n  if (a == 4) {\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 46, "end_line": 50}}
{"id": "interprocedural_006", "source_file": "pulse/interprocedural.c", "original_function_name": "propagate_latent_1_latent", "anonymized_function_name": "propagate_latent_1", "function_code": "void propagate_latent_1(int a1) { latent_dereference(a1, NULL); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void latent_dereference(int a, int* p) {\n  if (a == 4) {\n    *p = 42;\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 0, "absolute_line": 52, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `latent_dereference` here,parameter `p` of latent_dereference,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 52, "end_line": 52}}
{"id": "interprocedural_007", "source_file": "pulse/interprocedural.c", "original_function_name": "propagate_latent_2_latent", "anonymized_function_name": "propagate_latent_2", "function_code": "void propagate_latent_2(int a2) { propagate_latent_1_latent(a2); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void propagate_latent_1_latent(int a1) { latent_dereference(a1, NULL); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 54, "end_line": 54}}
{"id": "interprocedural_008", "source_file": "pulse/interprocedural.c", "original_function_name": "propagate_latent_3_latent", "anonymized_function_name": "propagate_latent_3", "function_code": "void propagate_latent_3(int a3) { propagate_latent_2_latent(a3); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void propagate_latent_2_latent(int a2) { propagate_latent_1_latent(a2); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 56, "end_line": 56}}
{"id": "interprocedural_009", "source_file": "pulse/interprocedural.c", "original_function_name": "make_latent_manifest", "anonymized_function_name": "make_latent_manifest", "function_code": "void make_latent_manifest() { propagate_latent_3_latent(4); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void propagate_latent_3_latent(int a3) { propagate_latent_2_latent(a3); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 0, "absolute_line": 58, "severity": "ERROR", "trace": "when calling `propagate_latent_3_latent` here,when calling `propagate_latent_2_latent` here,when calling `propagate_latent_1_latent` here,is assigned to the null pointer,when calling `latent_dereference` here,parameter `p` of latent_dereference,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 58, "end_line": 58}}
{"id": "interprocedural_010", "source_file": "pulse/interprocedural.c", "original_function_name": "return_first", "anonymized_function_name": "return_first", "function_code": "int* return_first(int* x, int a, int** out) {\n  int* w = x;\n  *out = w;\n  return w;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 60, "end_line": 64}}
{"id": "interprocedural_011", "source_file": "pulse/interprocedural.c", "original_function_name": "return_null", "anonymized_function_name": "return_null", "function_code": "int* return_null(int** out) {\n  int* p = NULL;\n  *out = p;\n  return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 66, "end_line": 70}}
{"id": "interprocedural_012", "source_file": "pulse/interprocedural.c", "original_function_name": "follow_value_by_ref_bad", "anonymized_function_name": "follow_value_by_ref", "function_code": "void follow_value_by_ref() {\n  int* y;\n  return_null(&y);\n  int* z;\n  return_first(y, 12, &z);\n  *z = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* return_first(int* x, int a, int** out) {\n  int* w = x;\n  *out = w;\n  return w;\n}\n", "int* return_null(int** out) {\n  int* p = NULL;\n  *out = p;\n  return p;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 78, "severity": "ERROR", "trace": "in call to `return_null`,is assigned to the null pointer,assigned,assigned,return from call to `return_null`,in call to `return_first`,parameter `x` of return_first,assigned,assigned,return from call to `return_first`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 73, "end_line": 79}}
{"id": "interprocedural_013", "source_file": "pulse/interprocedural.c", "original_function_name": "follow_value_by_ret_bad", "anonymized_function_name": "follow_value_by_ret", "function_code": "void follow_value_by_ret() {\n  int *dummy1, *dummy2;\n  int* y = return_null(&dummy1);\n  int* z = return_first(y, 12, &dummy2);\n  *z = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* return_first(int* x, int a, int** out) {\n  int* w = x;\n  *out = w;\n  return w;\n}\n", "int* return_null(int** out) {\n  int* p = NULL;\n  *out = p;\n  return p;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 86, "severity": "ERROR", "trace": "in call to `return_null`,is assigned to the null pointer,assigned,returned,return from call to `return_null`,assigned,in call to `return_first`,parameter `x` of return_first,assigned,returned,return from call to `return_first`,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 82, "end_line": 87}}
{"id": "interprocedural_014", "source_file": "pulse/interprocedural.c", "original_function_name": "malloc_wrapper_1", "anonymized_function_name": "malloc_wrapper_1", "function_code": "int* malloc_wrapper_1() {\n  int* x;\n  x = (int*)malloc(sizeof(int));\n  return x;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 89, "end_line": 93}}
{"id": "interprocedural_015", "source_file": "pulse/interprocedural.c", "original_function_name": "malloc_wrapper_2", "anonymized_function_name": "malloc_wrapper_2", "function_code": "int* malloc_wrapper_2(int b) {\n  if (b) {\n    return malloc_wrapper_1();\n  }\n  return NULL;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* malloc_wrapper_1() {\n  int* x;\n  x = (int*)malloc(sizeof(int));\n  return x;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 95, "end_line": 100}}
{"id": "interprocedural_016", "source_file": "pulse/interprocedural.c", "original_function_name": "free_wrapper", "anonymized_function_name": "free_wrapper", "function_code": "void free_wrapper(int* p, int b) {\n  if (b) {\n    free(p);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 102, "end_line": 106}}
{"id": "interprocedural_017", "source_file": "pulse/interprocedural.c", "original_function_name": "trace_correctly_through_wrappers_bad", "anonymized_function_name": "trace_correctly_through_wrappers", "function_code": "void trace_correctly_through_wrappers() {\n  int* x = malloc_wrapper_2(1);\n  // TODO: ideally we would trace that we didn't go into the free() branch of\n  // the wrapper explicitly here to help understand the bug report\n  free_wrapper(x, 0);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* malloc_wrapper_2(int b) {\n  if (b) {\n    return malloc_wrapper_1();\n  }\n  return NULL;\n}\n", "void free_wrapper(int* p, int b) {\n  if (b) {\n    free(p);\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 4, "absolute_line": 112, "severity": "ERROR", "trace": "allocation part of the trace starts here,when calling `malloc_wrapper_2` here,when calling `malloc_wrapper_1` here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": true, "category": "memory_leak", "start_line": 108, "end_line": 113}}
{"id": "issues_abort_execution_001", "source_file": "pulse/issues_abort_execution.c", "original_function_name": "uninit_continues_execution_bad", "anonymized_function_name": "uninit_continues_execution", "function_code": "void uninit_continues_execution() {\n  int x;\n  int y = x + 1;\n  int* p = NULL;\n  *p = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 2, "absolute_line": 13, "severity": "ERROR", "trace": "variable `x` declared here,read to uninitialized value occurs here"}, {"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 15, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 11, "end_line": 16}}
{"id": "issues_abort_execution_002", "source_file": "pulse/issues_abort_execution.c", "original_function_name": "leak_bad", "anonymized_function_name": "leak", "function_code": "void leak() {\n  int* p = malloc(sizeof(int));\n  assert(p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 2, "absolute_line": 20, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,macro expanded here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 18, "end_line": 21}}
{"id": "issues_abort_execution_003", "source_file": "pulse/issues_abort_execution.c", "original_function_name": "memleak_continues_execution_bad", "anonymized_function_name": "memleak_continues_execution", "function_code": "void memleak_continues_execution() {\n  leak_bad();\n  int* p = NULL;\n  *p = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void leak_bad() {\n  int* p = malloc(sizeof(int));\n  assert(p);\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 26, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 23, "end_line": 27}}
{"id": "latent_001", "source_file": "pulse/latent.c", "original_function_name": "conditional_free2", "anonymized_function_name": "conditional_free2", "function_code": "void conditional_free2(int b, int* x) {\n  if (b) {\n    free(x);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 10, "end_line": 14}}
{"id": "latent_002", "source_file": "pulse/latent.c", "original_function_name": "latent_use_after_free", "anonymized_function_name": "latent_use_after_free", "function_code": "void latent_use_after_free(int b, int* x) {\n  conditional_free2(b, x);\n  *x = 42;\n  if (!b) {\n    // just to avoid memory leaks\n    free(x);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void conditional_free2(int b, int* x) {\n  if (b) {\n    free(x);\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 2, "absolute_line": 18, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `x` of latent_use_after_free,invalid access occurs here"}, {"bug_type": "USE_AFTER_FREE_LATENT", "line_offset": 2, "absolute_line": 18, "severity": "ERROR", "trace": "invalidation part of the trace starts here,parameter `x` of latent_use_after_free,when calling `conditional_free2` here,parameter `x` of conditional_free2,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,parameter `x` of latent_use_after_free,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 16, "end_line": 23}}
{"id": "latent_003", "source_file": "pulse/latent.c", "original_function_name": "manifest_use_after_free", "anonymized_function_name": "manifest_use_after_free", "function_code": "void manifest_use_after_free(int* x) { latent_use_after_free(1, x); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void latent_use_after_free(int b, int* x) {\n  conditional_free2(b, x);\n  *x = 42;\n  if (!b) {\n    // just to avoid memory leaks\n    free(x);\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "USE_AFTER_FREE", "line_offset": 0, "absolute_line": 25, "severity": "ERROR", "trace": "invalidation part of the trace starts here,parameter `x` of latent_use_after_free,when calling `conditional_free2` here,parameter `x` of conditional_free2,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,parameter `x` of manifest_use_after_free,when calling `latent_use_after_free` here,parameter `x` of latent_use_after_free,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "use_after_free", "start_line": 25, "end_line": 25}}
{"id": "latent_004", "source_file": "pulse/latent.c", "original_function_name": "deref_then_free_then_deref_bad", "anonymized_function_name": "deref_then_free_then_deref", "function_code": "void deref_then_free_then_deref(int* x) {\n  *x = 42;\n  free(x);\n  *x = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 1, "absolute_line": 28, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `x` of deref_then_free_then_deref_bad,invalid access occurs here"}, {"bug_type": "USE_AFTER_FREE", "line_offset": 3, "absolute_line": 30, "severity": "ERROR", "trace": "invalidation part of the trace starts here,parameter `x` of deref_then_free_then_deref_bad,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,parameter `x` of deref_then_free_then_deref_bad,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "use_after_free", "start_line": 27, "end_line": 31}}
{"id": "latent_005", "source_file": "pulse/latent.c", "original_function_name": "create_branching", "anonymized_function_name": "create_branching", "function_code": "void create_branching(int b) {\n  if (b) {\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 33, "end_line": 36}}
{"id": "latent_006", "source_file": "pulse/latent.c", "original_function_name": "main", "anonymized_function_name": "main", "function_code": "int main(int argc, char** argv) {\n  int* x = malloc(sizeof(int));\n  if (x) {\n    latent_use_after_free(argc, x);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void latent_use_after_free(int b, int* x) {\n  conditional_free2(b, x);\n  *x = 42;\n  if (!b) {\n    // just to avoid memory leaks\n    free(x);\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "USE_AFTER_FREE", "line_offset": 3, "absolute_line": 59, "severity": "ERROR", "trace": "invalidation part of the trace starts here,parameter `x` of latent_use_after_free,when calling `conditional_free2` here,parameter `x` of conditional_free2,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,allocated by call to `malloc` (modelled),assigned,when calling `latent_use_after_free` here,parameter `x` of latent_use_after_free,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "use_after_free", "start_line": 56, "end_line": 61}}
{"id": "latent_007", "source_file": "pulse/latent.c", "original_function_name": "equal_to_stack_address_test_then_crash_bad", "anonymized_function_name": "equal_to_stack_address_test_then_crash", "function_code": "void equal_to_stack_address_test_then_crash(int x, int* y) {\n  if (y == &x) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 68, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 65, "end_line": 70}}
{"id": "latent_008", "source_file": "pulse/latent.c", "original_function_name": "crash_if_different_addresses", "anonymized_function_name": "crash_if_different_addresses", "function_code": "void crash_if_different_addresses(int* x, int* y) {\n  *x = 42;\n  *y = 52;\n  if (x != y) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 77, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 72, "end_line": 79}}
{"id": "latent_009", "source_file": "pulse/latent.c", "original_function_name": "traverse_and_crash_if_equal_to_root", "anonymized_function_name": "traverse_and_crash_if_equal_to_root", "function_code": "void traverse_and_crash_if_equal_to_root(struct node* p) {\n  struct node* old_p = p;\n  while (p != NULL) {\n    p = p->next;\n    if (old_p == p) {\n      int* crash = NULL;\n      *crash = 42;\n    }\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct node {\n  int data;\n  struct node* next;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 6, "absolute_line": 92, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 86, "end_line": 95}}
{"id": "latent_010", "source_file": "pulse/latent.c", "original_function_name": "crash_after_one_node_bad", "anonymized_function_name": "crash_after_one_node", "function_code": "void crash_after_one_node(struct node* q) {\n  q->next = q;\n  traverse_and_crash_if_equal_to_root(q);\n}\n", "includes": ["#include <stdlib.h>", "struct node {\n  int data;\n  struct node* next;\n};"], "dependencies": ["void traverse_and_crash_if_equal_to_root(struct node* p) {\n  struct node* old_p = p;\n  while (p != NULL) {\n    p = p->next;\n    if (old_p == p) {\n      int* crash = NULL;\n      *crash = 42;\n    }\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 1, "absolute_line": 98, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `q` of crash_after_one_node_bad,invalid access occurs here"}, {"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 99, "severity": "ERROR", "trace": "when calling `traverse_and_crash_if_equal_to_root` here,is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 97, "end_line": 100}}
{"id": "latent_011", "source_file": "pulse/latent.c", "original_function_name": "crash_after_two_nodes_bad", "anonymized_function_name": "crash_after_two_nodes", "function_code": "void crash_after_two_nodes(struct node* q) {\n  q->next->next = q;\n  traverse_and_crash_if_equal_to_root(q);\n}\n", "includes": ["#include <stdlib.h>", "struct node {\n  int data;\n  struct node* next;\n};"], "dependencies": ["void traverse_and_crash_if_equal_to_root(struct node* p) {\n  struct node* old_p = p;\n  while (p != NULL) {\n    p = p->next;\n    if (old_p == p) {\n      int* crash = NULL;\n      *crash = 42;\n    }\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 1, "absolute_line": 103, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `q` of crash_after_two_nodes_bad,invalid access occurs here"}, {"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 1, "absolute_line": 103, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `q` of crash_after_two_nodes_bad,invalid access occurs here"}, {"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 104, "severity": "ERROR", "trace": "when calling `traverse_and_crash_if_equal_to_root` here,is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 102, "end_line": 105}}
{"id": "list_api_001", "source_file": "pulse/list_api.c", "original_function_name": "list_init", "anonymized_function_name": "list_init", "function_code": "list_t* list_init() { return calloc(1, sizeof(list_t)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 19, "end_line": 19}}
{"id": "list_api_002", "source_file": "pulse/list_api.c", "original_function_name": "list_append", "anonymized_function_name": "list_append", "function_code": "void list_append(list_t* lst, list_elem_t* elem) {\n  list_elem_t* iter;\n\n  if (NULL == lst->first) {\n    lst->first = elem;\n  } else {\n    iter = lst->first;\n    while (NULL != iter->next) {\n      iter = iter->next;\n    }\n    iter->next = elem;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 21, "end_line": 33}}
{"id": "list_api_003", "source_file": "pulse/list_api.c", "original_function_name": "list_add", "anonymized_function_name": "list_add", "function_code": "list_elem_t* list_add(list_t* lst, void* data) {\n  list_elem_t* entry;\n\n  entry = calloc(1, sizeof(list_elem_t));\n  if (NULL == entry) {\n    return NULL;\n  }\n  entry->data = data;\n  list_append(lst, entry);\n  return (entry);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void list_append(list_t* lst, list_elem_t* elem) {\n  list_elem_t* iter;\n\n  if (NULL == lst->first) {\n    lst->first = elem;\n  } else {\n    iter = lst->first;\n    while (NULL != iter->next) {\n      iter = iter->next;\n    }\n    iter->next = elem;\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 35, "end_line": 45}}
{"id": "list_api_004", "source_file": "pulse/list_api.c", "original_function_name": "list_elem_free", "anonymized_function_name": "list_elem_free", "function_code": "void list_elem_free(list_elem_t* ptr) {\n  if (NULL == ptr) {\n    return;\n  }\n\n  list_elem_free(ptr->next);\n  free(ptr);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MUTUAL_RECURSION_CYCLE", "line_offset": 5, "absolute_line": 52, "severity": "WARNING", "trace": "`list_elem_free` makes a recursive call to `list_elem_free`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 47, "end_line": 54}}
{"id": "list_api_005", "source_file": "pulse/list_api.c", "original_function_name": "list_free", "anonymized_function_name": "list_free", "function_code": "void list_free(list_t* ptr) {\n  list_elem_free(ptr->first);\n  free(ptr);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void list_elem_free(list_elem_t* ptr) {\n  if (NULL == ptr) {\n    return;\n  }\n\n  list_elem_free(ptr->next);\n  free(ptr);\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 1, "absolute_line": 57, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `ptr` of list_free,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 56, "end_line": 59}}
{"id": "list_api_006", "source_file": "pulse/list_api.c", "original_function_name": "list_build_and_free_ok", "anonymized_function_name": "list_build_and_free", "function_code": "int list_build_and_free() {\n  int val_data = 21;\n\n  list_t* list = list_init();\n  if (NULL == list) {\n    return 1;\n  }\n  if (NULL == list_add(list, &val_data)) {\n    list_free(list);\n    return 1;\n  }\n  list_free(list);\n  return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["list_t* list_init() { return calloc(1, sizeof(list_t)); }\n", "list_elem_t* list_add(list_t* lst, void* data) {\n  list_elem_t* entry;\n\n  entry = calloc(1, sizeof(list_elem_t));\n  if (NULL == entry) {\n    return NULL;\n  }\n  entry->data = data;\n  list_append(lst, entry);\n  return (entry);\n}\n", "void list_free(list_t* ptr) {\n  list_elem_free(ptr->first);\n  free(ptr);\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 61, "end_line": 74}}
{"id": "list_checks_001", "source_file": "pulse/list_checks.c", "original_function_name": "go_to_next", "anonymized_function_name": "go_to_next", "function_code": "void go_to_next(struct list* head) {\n  if (head->next != NULL) {\n    head = head->next;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct list {\n  struct list* next;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 14, "end_line": 18}}
{"id": "list_checks_002", "source_file": "pulse/list_checks.c", "original_function_name": "null_ptr_deref_bad", "anonymized_function_name": "null_ptr_deref", "function_code": "void null_ptr_deref() { go_to_next(NULL); }\n", "includes": ["#include <stdlib.h>", "struct list {\n  struct list* next;\n};"], "dependencies": ["void go_to_next(struct list* head) {\n  if (head->next != NULL) {\n    head = head->next;\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 0, "absolute_line": 20, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `go_to_next` here,parameter `head` of go_to_next,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 20, "end_line": 20}}
{"id": "list_checks_003", "source_file": "pulse/list_checks.c", "original_function_name": "go_to_end_of_list", "anonymized_function_name": "go_to_end_of_list", "function_code": "void go_to_end_of_list(struct list* head) {\n  while (head->next != NULL) {\n    head = head->next;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct list {\n  struct list* next;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 22, "end_line": 26}}
{"id": "list_checks_004", "source_file": "pulse/list_checks.c", "original_function_name": "null_ptr_deref2_bad", "anonymized_function_name": "null_ptr_deref2", "function_code": "void null_ptr_deref2() { go_to_end_of_list(NULL); }\n", "includes": ["#include <stdlib.h>", "struct list {\n  struct list* next;\n};"], "dependencies": ["void go_to_end_of_list(struct list* head) {\n  while (head->next != NULL) {\n    head = head->next;\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 0, "absolute_line": 28, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `go_to_end_of_list` here,parameter `head` of go_to_end_of_list,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 28, "end_line": 28}}
{"id": "list_checks_005", "source_file": "pulse/list_checks.c", "original_function_name": "check_next", "anonymized_function_name": "check_next", "function_code": "void check_next(struct list* head) {\n  while (head->next != NULL) {\n    whatever();\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct list {\n  struct list* next;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 1, "absolute_line": 31, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 30, "end_line": 34}}
{"id": "list_checks_006", "source_file": "pulse/list_checks.c", "original_function_name": "null_ptr_deref3_bad", "anonymized_function_name": "null_ptr_deref3", "function_code": "void null_ptr_deref3() { check_next(NULL); }\n", "includes": ["#include <stdlib.h>", "struct list {\n  struct list* next;\n};"], "dependencies": ["void check_next(struct list* head) {\n  while (head->next != NULL) {\n    whatever();\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 0, "absolute_line": 36, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `check_next` here,parameter `head` of check_next,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 36, "end_line": 36}}
{"id": "lists_001", "source_file": "pulse/lists.c", "original_function_name": "add2", "anonymized_function_name": "add2", "function_code": "int add2(struct l2* l) {\n  int r = 0;\n  for (; l; l = l->a) {\n    r += l->b;\n  }\n  return r;\n}\n", "includes": ["#include <stdlib.h>", "struct l2 {\n  int b;\n  struct l2* a;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 15, "end_line": 21}}
{"id": "lists_002", "source_file": "pulse/lists.c", "original_function_name": "call_add2_then_deref_null_bad", "anonymized_function_name": "call_add2_then_deref_null", "function_code": "int call_add2_then_deref_null() {\n  int res = add2(NULL);\n  if (res == 0) {\n    int* p = NULL;\n    *p = 42; // reachable\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct l2 {\n  int b;\n  struct l2* a;\n};"], "dependencies": ["int add2(struct l2* l) {\n  int r = 0;\n  for (; l; l = l->a) {\n    r += l->b;\n  }\n  return r;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 27, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 23, "end_line": 29}}
{"id": "lists_003", "source_file": "pulse/lists.c", "original_function_name": "delete_one", "anonymized_function_name": "delete_one", "function_code": "void delete_one(T* x) { free(x); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 35, "end_line": 35}}
{"id": "lists_004", "source_file": "pulse/lists.c", "original_function_name": "delete_all", "anonymized_function_name": "delete_all", "function_code": "void delete_all(T* x) {\n  T* temp;\n  while (x != NULL) {\n    temp = x;\n    x = x->next;\n    free(temp);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 37, "end_line": 44}}
{"id": "lists_005", "source_file": "pulse/lists.c", "original_function_name": "call_delete_one_ok", "anonymized_function_name": "call_delete_one", "function_code": "int call_delete_one() {\n  T* root = malloc(sizeof(T));\n  delete_one(root); // no memory leak should be reported here\n  return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void delete_one(T* x) { free(x); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 46, "end_line": 50}}
{"id": "lists_006", "source_file": "pulse/lists.c", "original_function_name": "call_delete_all1_ok", "anonymized_function_name": "call_delete_all1", "function_code": "int call_delete_all1() {\n  T* root = malloc(sizeof(T));\n  delete_all(root); // no memory leak should be reported here\n  return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void delete_all(T* x) {\n  T* temp;\n  while (x != NULL) {\n    temp = x;\n    x = x->next;\n    free(temp);\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 52, "end_line": 56}}
{"id": "lists_007", "source_file": "pulse/lists.c", "original_function_name": "call_delete_all2_ok", "anonymized_function_name": "call_delete_all2", "function_code": "int call_delete_all2() {\n  T* root = malloc(sizeof(T));\n  if (root != NULL) {\n    root->next = malloc(sizeof(T));\n  }\n  delete_all(root); // no memory leak should be reported here\n  return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void delete_all(T* x) {\n  T* temp;\n  while (x != NULL) {\n    temp = x;\n    x = x->next;\n    free(temp);\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 58, "end_line": 65}}
{"id": "memcpy_001", "source_file": "pulse/memcpy.c", "original_function_name": "memcpy_ok", "anonymized_function_name": "memcpy", "function_code": "void memcpy() {\n  X x;\n  X* p = malloc(sizeof(X));\n  if (p)\n    memcpy(p, &x, sizeof(X));\n  free(p);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 16, "end_line": 22}}
{"id": "memcpy_002", "source_file": "pulse/memcpy.c", "original_function_name": "memcpy_to_null_bad", "anonymized_function_name": "memcpy_to_null", "function_code": "void memcpy_to_null() {\n  X x;\n  X* p = NULL;\n  memcpy(p, &x, sizeof(X)); // crash\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 27, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 24, "end_line": 28}}
{"id": "memcpy_003", "source_file": "pulse/memcpy.c", "original_function_name": "memcpy_to_null_indirect_bad", "anonymized_function_name": "memcpy_to_null_indirect", "function_code": "void memcpy_to_null_indirect() {\n  X x;\n  X* r;\n  X* p = NULL;\n  r = p;\n  memcpy(r, &x, sizeof(X)); // crash\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 35, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 30, "end_line": 36}}
{"id": "memcpy_004", "source_file": "pulse/memcpy.c", "original_function_name": "memcpy_from_null_bad", "anonymized_function_name": "memcpy_from_null", "function_code": "void memcpy_from_null() {\n  X* src = NULL;\n  X* p = malloc(sizeof(X));\n  if (p) {\n    memcpy(p, src, sizeof(X)); // crash\n    free(p);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 42, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 38, "end_line": 45}}
{"id": "memory_leak_001", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_no_free_bad", "anonymized_function_name": "malloc_no_free", "function_code": "void malloc_no_free() { int* p = malloc(sizeof(p)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 0, "absolute_line": 9, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 9, "end_line": 9}}
{"id": "memory_leak_002", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_returned_ok", "anonymized_function_name": "malloc_returned", "function_code": "int* malloc_returned() {\n  int* p = malloc(sizeof(p));\n  return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 11, "end_line": 14}}
{"id": "memory_leak_003", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_out_parameter_ok", "anonymized_function_name": "malloc_out_parameter", "function_code": "void malloc_out_parameter(int** x) { *x = (int*)malloc(sizeof(int)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 16, "end_line": 16}}
{"id": "memory_leak_004", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_out_parameter_local_mutation_ok", "anonymized_function_name": "malloc_out_parameter_local_mutation", "function_code": "void malloc_out_parameter_local_mutation(int** x) {\n  *x = (int*)malloc(sizeof(int));\n  x = NULL; // not visible from the outside\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 18, "end_line": 21}}
{"id": "memory_leak_005", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_out_parameter_local_mutation_bad", "anonymized_function_name": "malloc_out_parameter_local_mutation", "function_code": "void malloc_out_parameter_local_mutation(int** x) {\n  *x = (int*)malloc(sizeof(int));\n  *x = NULL;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 3, "absolute_line": 26, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 23, "end_line": 26}}
{"id": "memory_leak_006", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_then_free_ok", "anonymized_function_name": "malloc_then_free", "function_code": "void malloc_then_free() {\n  int* p = malloc(sizeof(p));\n  if (p) {\n    *p = 5;\n    free(p);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 28, "end_line": 34}}
{"id": "memory_leak_007", "source_file": "pulse/memory_leak.c", "original_function_name": "create_p", "anonymized_function_name": "create_p", "function_code": "int* create_p() {\n  int* p = malloc(sizeof(p));\n  return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 36, "end_line": 39}}
{"id": "memory_leak_008", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_interproc_no_free_bad", "anonymized_function_name": "malloc_interproc_no_free", "function_code": "void malloc_interproc_no_free() { int* p = create_p(); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* create_p() {\n  int* p = malloc(sizeof(p));\n  return p;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 0, "absolute_line": 41, "severity": "ERROR", "trace": "allocation part of the trace starts here,when calling `create_p` here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": true, "category": "memory_leak", "start_line": 41, "end_line": 41}}
{"id": "memory_leak_009", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_interproc_no_free_bad2", "anonymized_function_name": "malloc_interproc_no_free_bad2", "function_code": "void malloc_interproc_no_free_bad2() {\n  int* p = malloc(sizeof(p));\n  int z = 3;\n  int y = 4;\n  int* q = p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 4, "absolute_line": 47, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 43, "end_line": 48}}
{"id": "memory_leak_010", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_formal_leak_bad", "anonymized_function_name": "malloc_formal_leak", "function_code": "void malloc_formal_leak(int* x) { x = (int*)malloc(sizeof(int*)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 0, "absolute_line": 50, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 50, "end_line": 50}}
{"id": "memory_leak_011", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_via_ptr", "anonymized_function_name": "malloc_via_ptr", "function_code": "void* malloc_via_ptr(size_t size) {\n  void* ret = NULL;\n\n  if (size <= 0) {\n    return NULL;\n  }\n\n  ret = malloc_func(size);\n  return ret;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 55, "end_line": 64}}
{"id": "memory_leak_012", "source_file": "pulse/memory_leak.c", "original_function_name": "free_via_ptr", "anonymized_function_name": "free_via_ptr", "function_code": "void free_via_ptr(void* x) { free_func(x); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 66, "end_line": 66}}
{"id": "memory_leak_013", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_ptr_leak_bad", "anonymized_function_name": "malloc_ptr_leak", "function_code": "void malloc_ptr_leak() { int* p = (int*)malloc_via_ptr(sizeof(int)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void* malloc_via_ptr(size_t size) {\n  void* ret = NULL;\n\n  if (size <= 0) {\n    return NULL;\n  }\n\n  ret = malloc_func(size);\n  return ret;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 0, "absolute_line": 68, "severity": "ERROR", "trace": "allocation part of the trace starts here,when calling `malloc_via_ptr` here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": true, "category": "memory_leak", "start_line": 68, "end_line": 68}}
{"id": "memory_leak_014", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_ptr_no_check_leak_bad", "anonymized_function_name": "malloc_ptr_no_check_leak", "function_code": "void malloc_ptr_no_check_leak() {\n  int* p = (int*)malloc_via_ptr(sizeof(int));\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void* malloc_via_ptr(size_t size) {\n  void* ret = NULL;\n\n  if (size <= 0) {\n    return NULL;\n  }\n\n  ret = malloc_func(size);\n  return ret;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 2, "absolute_line": 72, "severity": "ERROR", "trace": "allocation part of the trace starts here,when calling `malloc_via_ptr` here,allocated by `malloc` here,memory becomes unreachable here"}, {"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 72, "severity": "ERROR", "trace": "in call to `malloc_via_ptr`,in call to `malloc (null case)` (modelled),is assigned to the null pointer,assigned,returned,return from call to `malloc_via_ptr`,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 70, "end_line": 73}}
{"id": "memory_leak_015", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_ptr_free_ok", "anonymized_function_name": "malloc_ptr_free", "function_code": "void malloc_ptr_free() {\n  int* p = (int*)malloc_via_ptr(sizeof(int));\n  free(p);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void* malloc_via_ptr(size_t size) {\n  void* ret = NULL;\n\n  if (size <= 0) {\n    return NULL;\n  }\n\n  ret = malloc_func(size);\n  return ret;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 75, "end_line": 78}}
{"id": "memory_leak_016", "source_file": "pulse/memory_leak.c", "original_function_name": "malloc_ptr_free_ptr_ok", "anonymized_function_name": "malloc_ptr_free_ptr", "function_code": "void malloc_ptr_free_ptr() {\n  int* p = (int*)malloc_via_ptr(sizeof(int));\n  free_via_ptr(p);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void* malloc_via_ptr(size_t size) {\n  void* ret = NULL;\n\n  if (size <= 0) {\n    return NULL;\n  }\n\n  ret = malloc_func(size);\n  return ret;\n}\n", "void free_via_ptr(void* x) { free_func(x); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 80, "end_line": 83}}
{"id": "memory_leak_017", "source_file": "pulse/memory_leak.c", "original_function_name": "alias_ptr_free_ok", "anonymized_function_name": "alias_ptr_free", "function_code": "void alias_ptr_free(int* out, int flag) {\n  int* y;\n  if (flag) {\n    y = (int*)malloc(sizeof(int));\n  } else {\n    y = out;\n  }\n  if (y && y != out) {\n    free(y);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 85, "end_line": 95}}
{"id": "memory_leak_018", "source_file": "pulse/memory_leak.c", "original_function_name": "report_leak_in_correct_line_bad", "anonymized_function_name": "report_leak_in_correct_line", "function_code": "void report_leak_in_correct_line(int* x) {\n  x = (int*)malloc(sizeof(int));\n  if (x != NULL) {\n    return; // should report leak at this line\n  }\n  free(x);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 2, "absolute_line": 99, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 97, "end_line": 103}}
{"id": "memory_leak_019", "source_file": "pulse/memory_leak.c", "original_function_name": "realloc_wrapper", "anonymized_function_name": "realloc_wrapper", "function_code": "void* realloc_wrapper(void* p, size_t size) { return realloc(p, size); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 105, "end_line": 105}}
{"id": "memory_leak_020", "source_file": "pulse/memory_leak.c", "original_function_name": "realloc_free_ok", "anonymized_function_name": "realloc_free", "function_code": "void realloc_free() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = realloc_wrapper(p, sizeof(int));\n  free(q);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void* realloc_wrapper(void* p, size_t size) { return realloc(p, size); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 107, "end_line": 111}}
{"id": "memory_leak_021", "source_file": "pulse/memory_leak.c", "original_function_name": "realloc_no_free_bad", "anonymized_function_name": "realloc_no_free", "function_code": "void realloc_no_free() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = realloc_wrapper(p, sizeof(int));\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void* realloc_wrapper(void* p, size_t size) { return realloc(p, size); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 2, "absolute_line": 115, "severity": "ERROR", "trace": "allocation part of the trace starts here,when calling `realloc_wrapper` here,allocated by `realloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": true, "category": "memory_leak", "start_line": 113, "end_line": 116}}
{"id": "memory_leak_022", "source_file": "pulse/memory_leak.c", "original_function_name": "realloc_no_check_bad", "anonymized_function_name": "realloc_no_check", "function_code": "void realloc_no_check() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = realloc_wrapper(p, sizeof(int));\n  *q = 42;\n  free(q);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void* realloc_wrapper(void* p, size_t size) { return realloc(p, size); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 121, "severity": "ERROR", "trace": "in call to `realloc_wrapper`,in call to `realloc (null case)` (modelled),is assigned to the null pointer,returned,return from call to `realloc_wrapper`,assigned,invalid access occurs here"}, {"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 121, "severity": "ERROR", "trace": "in call to `malloc (null case)` (modelled),is assigned to the null pointer,assigned,in call to `realloc_wrapper`,in call to `realloc (null case)` (modelled),is assigned to the null pointer,returned,return from call to `realloc_wrapper`,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 118, "end_line": 123}}
{"id": "memory_leak_023", "source_file": "pulse/memory_leak.c", "original_function_name": "user_malloc_leak_bad", "anonymized_function_name": "user_malloc_leak", "function_code": "void user_malloc_leak() { int* x = (int*)a_malloc(sizeof(int)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 0, "absolute_line": 130, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `a_malloc (custom malloc)` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 130, "end_line": 130}}
{"id": "memory_leak_024", "source_file": "pulse/memory_leak.c", "original_function_name": "test_config_options_1_ok", "anonymized_function_name": "test_config_options_1", "function_code": "void test_config_options_1() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = my_realloc(p, sizeof(int));\n  my_free(q);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 132, "end_line": 136}}
{"id": "memory_leak_025", "source_file": "pulse/memory_leak.c", "original_function_name": "test_config_options_2_ok", "anonymized_function_name": "test_config_options_2", "function_code": "void test_config_options_2() {\n  int* p = (int*)my_malloc(sizeof(int));\n  int* q = realloc(p, sizeof(int));\n  my_free(q);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 138, "end_line": 142}}
{"id": "memory_leak_026", "source_file": "pulse/memory_leak.c", "original_function_name": "test_config_options_no_free_bad", "anonymized_function_name": "test_config_options_no_free", "function_code": "void test_config_options_no_free() {\n  int* p = (int*)my_malloc(sizeof(int));\n  int* q = my_realloc(p, sizeof(int));\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 2, "absolute_line": 146, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `my_realloc (custom realloc)` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 144, "end_line": 147}}
{"id": "memory_leak_027", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_ref_counted_ok", "anonymized_function_name": "alloc_ref_counted", "function_code": "int* alloc_ref_counted() {\n  struct ref_counted* p =\n      (struct ref_counted*)malloc(sizeof(struct ref_counted));\n  if (p) {\n    p->count = 1;\n    return &(p->data);\n  } else {\n    return NULL;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct ref_counted {\n  size_t count;\n  int data;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 156, "end_line": 165}}
{"id": "memory_leak_028", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_ref_counted_bad", "anonymized_function_name": "alloc_ref_counted", "function_code": "int alloc_ref_counted() {\n  struct ref_counted* p =\n      (struct ref_counted*)malloc(sizeof(struct ref_counted));\n  if (p) {\n    p->count = 1;\n    p->data = 42;\n    return p->data;\n  } else {\n    return 0;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct ref_counted {\n  size_t count;\n  int data;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 6, "absolute_line": 174, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 168, "end_line": 178}}
{"id": "memory_leak_029", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_ref_counted_arith_ok", "anonymized_function_name": "alloc_ref_counted_arith", "function_code": "void* alloc_ref_counted_arith(size_t size) {\n  int* p = (int*)malloc(size + sizeof(int));\n  if (p) {\n    // register count = 1 and point past the ref count\n    *p++ = 1;\n  }\n  return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 182, "end_line": 189}}
{"id": "memory_leak_030", "source_file": "pulse/memory_leak.c", "original_function_name": "return_malloc_deref_bad", "anonymized_function_name": "return_malloc_deref", "function_code": "int return_malloc_deref() {\n  int* p = (int*)malloc(sizeof(int));\n  if (p) {\n    *p = 42;\n    return *p;\n  }\n  return 10;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 4, "absolute_line": 195, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 191, "end_line": 198}}
{"id": "memory_leak_031", "source_file": "pulse/memory_leak.c", "original_function_name": "mutual_recursion", "anonymized_function_name": "mutual_recursion", "function_code": "void mutual_recursion(NODE* x) { mutual_recursion_2(x); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void mutual_recursion_2(NODE* x) { mutual_recursion(x); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 206, "severity": "WARNING", "trace": "`mutual_recursion` calls `mutual_recursion_2`,`mutual_recursion_2` makes a recursive call to `mutual_recursion` with the same argument values"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 206, "end_line": 206}}
{"id": "memory_leak_032", "source_file": "pulse/memory_leak.c", "original_function_name": "mutual_recursion_2", "anonymized_function_name": "mutual_recursion_2", "function_code": "void mutual_recursion_2(NODE* x) { mutual_recursion(x); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void mutual_recursion(NODE* x) { mutual_recursion_2(x); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 208, "severity": "WARNING", "trace": "`mutual_recursion_2` calls `mutual_recursion`,`mutual_recursion` makes a recursive call to `mutual_recursion_2` with the same argument values"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 208, "end_line": 208}}
{"id": "memory_leak_033", "source_file": "pulse/memory_leak.c", "original_function_name": "interproc_mutual_recusion_leak", "anonymized_function_name": "interproc_mutual_recusion_leak", "function_code": "void interproc_mutual_recusion_leak(NODE* x) {\n  int* d;\n  if (x->data == NULL) {\n    x->data = (int*)malloc(sizeof(int));\n  }\n  mutual_recursion(x);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void mutual_recursion(NODE* x) { mutual_recursion_2(x); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 210, "end_line": 216}}
{"id": "memory_leak_034", "source_file": "pulse/memory_leak.c", "original_function_name": "allocate_all_in_array", "anonymized_function_name": "allocate_all_in_array", "function_code": "void allocate_all_in_array(int* array[]) {\n  for (int i = 0; i < 2; i++) {\n    array[i] = malloc(sizeof(int));\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 218, "end_line": 222}}
{"id": "memory_leak_035", "source_file": "pulse/memory_leak.c", "original_function_name": "free_all_in_array", "anonymized_function_name": "free_all_in_array", "function_code": "void free_all_in_array(int* array[]) {\n  for (int i = 0; i < 2; i++) {\n    free(array[i]);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 224, "end_line": 228}}
{"id": "memory_leak_036", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_then_free_all_in_array_ok", "anonymized_function_name": "alloc_then_free_all_in_array", "function_code": "void alloc_then_free_all_in_array() {\n  int* array[2];\n  allocate_all_in_array(array);\n  free_all_in_array(array);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void allocate_all_in_array(int* array[]) {\n  for (int i = 0; i < 2; i++) {\n    array[i] = malloc(sizeof(int));\n  }\n}\n", "void free_all_in_array(int* array[]) {\n  for (int i = 0; i < 2; i++) {\n    free(array[i]);\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 230, "end_line": 234}}
{"id": "memory_leak_037", "source_file": "pulse/memory_leak.c", "original_function_name": "allocate_42_in_array", "anonymized_function_name": "allocate_42_in_array", "function_code": "void allocate_42_in_array(int* array[]) { array[42] = malloc(sizeof(int)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 236, "end_line": 236}}
{"id": "memory_leak_038", "source_file": "pulse/memory_leak.c", "original_function_name": "free_42_in_array", "anonymized_function_name": "free_42_in_array", "function_code": "void free_42_in_array(int* array[]) { free(array[42]); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 238, "end_line": 238}}
{"id": "memory_leak_039", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_then_free_42_in_array_ok", "anonymized_function_name": "alloc_then_free_42_in_array", "function_code": "void alloc_then_free_42_in_array() {\n  int* array[64];\n  allocate_42_in_array(array);\n  free_42_in_array(array);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void allocate_42_in_array(int* array[]) { array[42] = malloc(sizeof(int)); }\n", "void free_42_in_array(int* array[]) { free(array[42]); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 240, "end_line": 244}}
{"id": "memory_leak_040", "source_file": "pulse/memory_leak.c", "original_function_name": "allocate_in_array", "anonymized_function_name": "allocate_in_array", "function_code": "void allocate_in_array(int* array[], int i) { array[i] = malloc(sizeof(int)); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 246, "end_line": 246}}
{"id": "memory_leak_041", "source_file": "pulse/memory_leak.c", "original_function_name": "free_in_array", "anonymized_function_name": "free_in_array", "function_code": "void free_in_array(int* array[], int i) { free(array[i]); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 248, "end_line": 248}}
{"id": "memory_leak_042", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_then_free_fixed_index_ok", "anonymized_function_name": "alloc_then_free_fixed_index", "function_code": "void alloc_then_free_fixed_index() {\n  int* array[64];\n  allocate_in_array(array, 42);\n  free_in_array(array, 42);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void allocate_in_array(int* array[], int i) { array[i] = malloc(sizeof(int)); }\n", "void free_in_array(int* array[], int i) { free(array[i]); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 250, "end_line": 254}}
{"id": "memory_leak_043", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_then_free_parameter_array_ok", "anonymized_function_name": "alloc_then_free_parameter_array", "function_code": "void alloc_then_free_parameter_array(int* array[], int i) {\n  allocate_in_array(array, i);\n  free_in_array(array, i);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void allocate_in_array(int* array[], int i) { array[i] = malloc(sizeof(int)); }\n", "void free_in_array(int* array[], int i) { free(array[i]); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 256, "end_line": 259}}
{"id": "memory_leak_044", "source_file": "pulse/memory_leak.c", "original_function_name": "alloc_then_free_at_index_ok", "anonymized_function_name": "alloc_then_free_at_index", "function_code": "void alloc_then_free_at_index(int i) {\n  int* array[64];\n  allocate_in_array(array, i);\n  free_in_array(array, i);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void allocate_in_array(int* array[], int i) { array[i] = malloc(sizeof(int)); }\n", "void free_in_array(int* array[], int i) { free(array[i]); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 261, "end_line": 265}}
{"id": "memory_leak_more_001", "source_file": "pulse/memory_leak_more.c", "original_function_name": "simple_leak_bad", "anonymized_function_name": "simple_leak", "function_code": "void simple_leak() {\n  int* p;\n  p = (int*)malloc(sizeof(int));\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 2, "absolute_line": 13, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 11, "end_line": 14}}
{"id": "memory_leak_more_002", "source_file": "pulse/memory_leak_more.c", "original_function_name": "allocate", "anonymized_function_name": "allocate", "function_code": "int* allocate() {\n  int* p = NULL;\n  do {\n    p = (int*)malloc(sizeof(int));\n  } while (p == NULL);\n  return p;\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 36, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 34, "end_line": 40}}
{"id": "memory_leak_more_003", "source_file": "pulse/memory_leak_more.c", "original_function_name": "leak_via_allocator_bad", "anonymized_function_name": "leak_via_allocator", "function_code": "void leak_via_allocator() {\n  int* p;\n  p = allocate();\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": ["int* allocate() {\n  int* p = NULL;\n  do {\n    p = (int*)malloc(sizeof(int));\n  } while (p == NULL);\n  return p;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 3, "absolute_line": 45, "severity": "ERROR", "trace": "allocation part of the trace starts here,when calling `allocate` here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": true, "category": "memory_leak", "start_line": 42, "end_line": 46}}
{"id": "memory_leak_more_004", "source_file": "pulse/memory_leak_more.c", "original_function_name": "return_memset_ok", "anonymized_function_name": "return_memset", "function_code": "void* return_memset(size_t s) {\n  char* str = malloc(sizeof(s));\n  if (str) {\n    return memset(str, 0, s);\n  }\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 48, "end_line": 53}}
{"id": "memory_leak_more_005", "source_file": "pulse/memory_leak_more.c", "original_function_name": "conditional_last_instruction_bad", "anonymized_function_name": "conditional_last_instruction", "function_code": "void conditional_last_instruction() {\n  int* p = malloc(sizeof(int));\n  if (0) {\n    free(p);\n  }\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 2, "absolute_line": 57, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "memory_leak", "start_line": 55, "end_line": 60}}
{"id": "memory_leak_more_006", "source_file": "pulse/memory_leak_more.c", "original_function_name": "compound_return_ok", "anonymized_function_name": "compound_return", "function_code": "int* compound_return() {\n  return ({\n    int* p = malloc(sizeof(int));\n    p;\n  });\n}\n", "includes": ["#include <stdlib.h>", "#include <string.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 62, "end_line": 67}}
{"id": "nullptr_001", "source_file": "pulse/nullptr.c", "original_function_name": "malloc_no_check_bad", "anonymized_function_name": "malloc_no_check", "function_code": "int* malloc_no_check() {\n  int* p = (int*)malloc(sizeof(int));\n  *p = 42;\n  return p;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 14, "severity": "ERROR", "trace": "in call to `malloc (null case)` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 12, "end_line": 16}}
{"id": "nullptr_002", "source_file": "pulse/nullptr.c", "original_function_name": "malloc_assert_ok", "anonymized_function_name": "malloc_assert", "function_code": "void malloc_assert() {\n  int* p = (int*)malloc(sizeof(int));\n  assert(p);\n  *p = 42;\n  free(p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 18, "end_line": 23}}
{"id": "nullptr_003", "source_file": "pulse/nullptr.c", "original_function_name": "create_null_path_ok", "anonymized_function_name": "create_null_path", "function_code": "void create_null_path(int* p) {\n  if (p) {\n    *p = 32;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 25, "end_line": 29}}
{"id": "nullptr_004", "source_file": "pulse/nullptr.c", "original_function_name": "call_create_null_path_then_deref_unconditionally_ok", "anonymized_function_name": "call_create_null_path_then_deref_unconditionally", "function_code": "void call_create_null_path_then_deref_unconditionally(int* p) {\n  create_null_path_ok(p);\n  *p = 52;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void create_null_path_ok(int* p) {\n  if (p) {\n    *p = 32;\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 31, "end_line": 34}}
{"id": "nullptr_005", "source_file": "pulse/nullptr.c", "original_function_name": "create_null_path2_bad_FN", "anonymized_function_name": "create_null_path2_bad_FN", "function_code": "void create_null_path2_bad_FN(int* p) {\n  int* q = NULL;\n  if (p) {\n    *p = 32;\n  }\n  // arguably bogus to check p above but not here, but the above could\n  // also be macro-generated code so both reporting and not reporting\n  // are sort of justifiable\n  *p = 52;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 8, "absolute_line": 44, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,assigned,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `p` of create_null_path2_bad_FN,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 36, "end_line": 45}}
{"id": "nullptr_006", "source_file": "pulse/nullptr.c", "original_function_name": "nullptr_deref_young_bad", "anonymized_function_name": "nullptr_deref_young", "function_code": "void nullptr_deref_young(int* x) {\n  int* vec[65] = {x, x, x, x, x, x, x, x, x, x, x, x, x, x,   x, x, x,\n                  x, x, x, x, x, x, x, x, x, x, x, x, x, x,   x, x, x,\n                  x, x, x, x, x, x, x, x, x, x, x, x, x, x,   x, x, x,\n                  x, x, x, x, x, x, x, x, x, x, x, x, x, NULL};\n  int p = *vec[64];\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 65, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 60, "end_line": 66}}
{"id": "nullptr_007", "source_file": "pulse/nullptr.c", "original_function_name": "malloc_free_ok", "anonymized_function_name": "malloc_free", "function_code": "void malloc_free() {\n  int* p = (int*)malloc(sizeof(int));\n  free(p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 79, "end_line": 82}}
{"id": "nullptr_008", "source_file": "pulse/nullptr.c", "original_function_name": "wrap_free", "anonymized_function_name": "wrap_free", "function_code": "void wrap_free(void* p) { free(p); }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 84, "end_line": 84}}
{"id": "nullptr_009", "source_file": "pulse/nullptr.c", "original_function_name": "interproc_free_ok", "anonymized_function_name": "interproc_free", "function_code": "void interproc_free() {\n  int* p = (int*)malloc(sizeof(int));\n  wrap_free(p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void wrap_free(void* p) { free(p); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 86, "end_line": 89}}
{"id": "nullptr_010", "source_file": "pulse/nullptr.c", "original_function_name": "wrap_malloc", "anonymized_function_name": "wrap_malloc", "function_code": "void wrap_malloc(int** x) {\n  *x = (int*)malloc(sizeof(int));\n  if (!*x) {\n    no_return();\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 93, "end_line": 98}}
{"id": "nullptr_011", "source_file": "pulse/nullptr.c", "original_function_name": "call_no_return_good", "anonymized_function_name": "call_no_return", "function_code": "void call_no_return() {\n  int* x = NULL;\n  wrap_malloc(&x);\n  *x = 5;\n  free(x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void wrap_malloc(int** x) {\n  *x = (int*)malloc(sizeof(int));\n  if (!*x) {\n    no_return();\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 100, "end_line": 105}}
{"id": "nullptr_012", "source_file": "pulse/nullptr.c", "original_function_name": "bug_after_malloc_result_test_bad", "anonymized_function_name": "bug_after_malloc_result_test", "function_code": "void bug_after_malloc_result_test(int* x) {\n  x = (int*)malloc(sizeof(int));\n  if (x) {\n    int* y = NULL;\n    *y = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 111, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 107, "end_line": 113}}
{"id": "nullptr_013", "source_file": "pulse/nullptr.c", "original_function_name": "bug_after_abduction_bad", "anonymized_function_name": "bug_after_abduction", "function_code": "void bug_after_abduction(int* x) {\n  *x = 42;\n  int* y = NULL;\n  *y = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 118, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 115, "end_line": 119}}
{"id": "nullptr_014", "source_file": "pulse/nullptr.c", "original_function_name": "bug_with_allocation_bad", "anonymized_function_name": "bug_with_allocation", "function_code": "void bug_with_allocation(int* x) {\n  x = (int*)malloc(sizeof(int));\n  int* y = NULL;\n  *y = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 124, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 121, "end_line": 125}}
{"id": "nullptr_015", "source_file": "pulse/nullptr.c", "original_function_name": "null_alias_bad", "anonymized_function_name": "null_alias", "function_code": "void null_alias(int* x) {\n  int* y = NULL;\n  x = (int*)malloc(sizeof(int*));\n  *x = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MEMORY_LEAK_C", "line_offset": 3, "absolute_line": 130, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `malloc` here,memory becomes unreachable here"}, {"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 130, "severity": "ERROR", "trace": "in call to `malloc (null case)` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 127, "end_line": 131}}
{"id": "nullptr_016", "source_file": "pulse/nullptr.c", "original_function_name": "dereference", "anonymized_function_name": "dereference", "function_code": "void dereference(int* p) { int i = *p; }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 133, "end_line": 133}}
{"id": "nullptr_017", "source_file": "pulse/nullptr.c", "original_function_name": "several_dereferences_ok", "anonymized_function_name": "several_dereferences", "function_code": "void several_dereferences(int* x, int* y, int* z) {\n  int* p = x;\n  *z = 52;\n  dereference(y);\n  *y = 42;\n  *x = 32;\n  *x = 777;\n  *y = 888;\n  *z = 999;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void dereference(int* p) { int i = *p; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 135, "end_line": 144}}
{"id": "nullptr_018", "source_file": "pulse/nullptr.c", "original_function_name": "report_correct_error_among_multiple_bad", "anonymized_function_name": "report_correct_error_among_multiple", "function_code": "void report_correct_error_among_multiple() {\n  int* p = NULL;\n  // the trace should complain about the first access inside the callee\n  several_dereferences_ok(p, p, p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void several_dereferences_ok(int* x, int* y, int* z) {\n  int* p = x;\n  *z = 52;\n  dereference(y);\n  *y = 42;\n  *x = 32;\n  *x = 777;\n  *y = 888;\n  *z = 999;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 149, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,when calling `several_dereferences_ok` here,parameter `z` of several_dereferences_ok,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 146, "end_line": 150}}
{"id": "nullptr_019", "source_file": "pulse/nullptr.c", "original_function_name": "unknown_is_functional_ok", "anonymized_function_name": "unknown_is_functional", "function_code": "void unknown_is_functional() {\n  int* p = NULL;\n  if (unknown(10) != unknown(10)) {\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 154, "end_line": 159}}
{"id": "nullptr_020", "source_file": "pulse/nullptr.c", "original_function_name": "unknown_with_different_values_bad", "anonymized_function_name": "unknown_with_different_values", "function_code": "void unknown_with_different_values() {\n  int* p = NULL;\n  if (unknown(32) != unknown(52)) {\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 164, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 161, "end_line": 166}}
{"id": "nullptr_021", "source_file": "pulse/nullptr.c", "original_function_name": "unknown_conditional_dereference", "anonymized_function_name": "unknown_conditional_dereference", "function_code": "void unknown_conditional_dereference(int x, int* p) {\n  if (unknown(x) == 999) {\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 168, "end_line": 172}}
{"id": "nullptr_022", "source_file": "pulse/nullptr.c", "original_function_name": "unknown_from_parameters_latent", "anonymized_function_name": "unknown_from_parameters", "function_code": "void unknown_from_parameters(int x) {\n  unknown_conditional_dereference(x, NULL);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void unknown_conditional_dereference(int x, int* p) {\n  if (unknown(x) == 999) {\n    *p = 42;\n  }\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE_LATENT", "line_offset": 1, "absolute_line": 175, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `unknown_conditional_dereference` here,parameter `p` of unknown_conditional_dereference,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 174, "end_line": 176}}
{"id": "nullptr_023", "source_file": "pulse/nullptr.c", "original_function_name": "random_non_functional_bad", "anonymized_function_name": "random_non_functional", "function_code": "void random_non_functional() {\n  if (random() != random()) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 182, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 179, "end_line": 184}}
{"id": "nullptr_024", "source_file": "pulse/nullptr.c", "original_function_name": "random_modelled_bad", "anonymized_function_name": "random_modelled", "function_code": "void random_modelled(int y) {\n  int x = random();\n  if (x == y) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 190, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 186, "end_line": 192}}
{"id": "nullptr_025", "source_file": "pulse/nullptr.c", "original_function_name": "arithmetic_weakness_ok", "anonymized_function_name": "arithmetic_weakness", "function_code": "void arithmetic_weakness() {\n  int x = random();\n  int y = random();\n  if (x < y && x > y) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 194, "end_line": 201}}
{"id": "nullptr_026", "source_file": "pulse/nullptr.c", "original_function_name": "no_invalidation_compare_to_NULL_bad", "anonymized_function_name": "no_invalidation_compare_to_NULL", "function_code": "void no_invalidation_compare_to_NULL() {\n  int* p = unknown_int_pointer();\n  int x;\n  int* q = &x;\n  if (p == NULL) {\n    q = p;\n  }\n  *q = 42;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "COMPARED_TO_NULL_AND_DEREFERENCED", "line_offset": 7, "absolute_line": 212, "severity": "ERROR", "trace": "compared to null here,in call to function `unknown_int_pointer` with no summary,assigned,was compared to null on line 209, column 7,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 205, "end_line": 213}}
{"id": "nullptr_027", "source_file": "pulse/nullptr.c", "original_function_name": "incr_deref", "anonymized_function_name": "incr_deref", "function_code": "void incr_deref(int* x, int* y) {\n  (*x)++;\n  (*y)++;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 215, "end_line": 218}}
{"id": "nullptr_028", "source_file": "pulse/nullptr.c", "original_function_name": "call_incr_deref_with_alias_bad", "anonymized_function_name": "call_incr_deref_with_alias", "function_code": "void call_incr_deref_with_alias(void) {\n  int x = 0;\n  int* ptr = &x;\n  incr_deref(ptr, ptr);\n  if (x == 2) {\n    ptr = NULL;\n  }\n  x = *ptr;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void incr_deref(int* x, int* y) {\n  (*x)++;\n  (*y)++;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 7, "absolute_line": 227, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 220, "end_line": 228}}
{"id": "nullptr_029", "source_file": "pulse/nullptr.c", "original_function_name": "call_incr_deref_with_alias_good", "anonymized_function_name": "call_incr_deref_with_alias", "function_code": "void call_incr_deref_with_alias(void) {\n  int x = 0;\n  int* ptr = &x;\n  incr_deref(ptr, ptr);\n  if (x != 2) {\n    ptr = NULL;\n  }\n  x = *ptr;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "#include <stdnoreturn.h>"], "dependencies": ["void incr_deref(int* x, int* y) {\n  (*x)++;\n  (*y)++;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 230, "end_line": 238}}
{"id": "nullptr_more_001", "source_file": "pulse/nullptr_more.c", "original_function_name": "simple_null_pointer_bad", "anonymized_function_name": "simple_null_pointer", "function_code": "int simple_null_pointer() {\n  struct Person* max = NULL;\n  return max->age;\n}\n", "includes": ["#include <stdlib.h>", "struct Person {\n  int age;\n  int height;\n  int weight;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 18, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 16, "end_line": 19}}
{"id": "nullptr_more_002", "source_file": "pulse/nullptr_more.c", "original_function_name": "get_age", "anonymized_function_name": "get_age", "function_code": "int get_age(struct Person* who) { return who->age; }\n", "includes": ["#include <stdlib.h>", "struct Person {\n  int age;\n  int height;\n  int weight;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 26, "end_line": 26}}
{"id": "nullptr_more_003", "source_file": "pulse/nullptr_more.c", "original_function_name": "null_pointer_interproc_bad", "anonymized_function_name": "null_pointer_interproc", "function_code": "int null_pointer_interproc() {\n  struct Person* joe = Person_create(32, 64, 140);\n  return get_age(joe);\n}\n", "includes": ["#include <stdlib.h>", "struct Person {\n  int age;\n  int height;\n  int weight;\n};"], "dependencies": ["int get_age(struct Person* who) { return who->age; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 30, "severity": "ERROR", "trace": "in call to `Person_create`,is assigned to the null pointer,assigned,returned,return from call to `Person_create`,assigned,when calling `get_age` here,parameter `who` of get_age,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 28, "end_line": 31}}
{"id": "nullptr_more_004", "source_file": "pulse/nullptr_more.c", "original_function_name": "negation_in_conditional_ok", "anonymized_function_name": "negation_in_conditional", "function_code": "int negation_in_conditional() {\n  int* x = NULL;\n  if (!x)\n    return 0;\n  else\n    return *x; // this never happens\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 33, "end_line": 39}}
{"id": "nullptr_more_005", "source_file": "pulse/nullptr_more.c", "original_function_name": "null_pointer_with_function_pointer_bad", "anonymized_function_name": "null_pointer_with_function_pointer", "function_code": "void null_pointer_with_function_pointer() {\n  int* (*fp)();\n  fp = return_null;\n  int* x = fp();\n  *x = 3;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 47, "severity": "ERROR", "trace": "in call to `return_null`,is assigned to the null pointer,returned,return from call to `return_null`,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 43, "end_line": 48}}
{"id": "nullptr_more_006", "source_file": "pulse/nullptr_more.c", "original_function_name": "exit_if_null_ok", "anonymized_function_name": "exit_if_null", "function_code": "void exit_if_null(struct Person* htbl) {\n  if (!htbl)\n    exit(0);\n  int x = htbl->age;\n}\n", "includes": ["#include <stdlib.h>", "struct Person {\n  int age;\n  int height;\n  int weight;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 50, "end_line": 54}}
{"id": "nullptr_more_007", "source_file": "pulse/nullptr_more.c", "original_function_name": "FPuseafterfree_no_check_for_null_after_realloc_bad", "anonymized_function_name": "FPuseafterfree_no_check_for_null_after_realloc", "function_code": "void FPuseafterfree_no_check_for_null_after_realloc() {\n  int* p;\n  p = (int*)malloc(sizeof(int) * 5);\n  if (p) {\n    p[3] = 42;\n  }\n  int* q = (int*)realloc(p, sizeof(int) * 10);\n  if (!q)\n    free(p); // FP\n  q[7] = 0; // NULL dereference\n  free(q);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "USE_AFTER_FREE", "line_offset": 8, "absolute_line": 64, "severity": "ERROR", "trace": "invalidation part of the trace starts here,allocated by call to `malloc` (modelled),assigned,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,allocated by call to `malloc` (modelled),assigned,invalid access occurs here"}, {"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 9, "absolute_line": 65, "severity": "ERROR", "trace": "in call to `realloc (null case)` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 56, "end_line": 67}}
{"id": "nullptr_more_008", "source_file": "pulse/nullptr_more.c", "original_function_name": "assign", "anonymized_function_name": "assign", "function_code": "void assign(int* p, int n) { *p = n; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 69, "end_line": 69}}
{"id": "nullptr_more_009", "source_file": "pulse/nullptr_more.c", "original_function_name": "potentially_null_pointer_passed_as_argument_bad", "anonymized_function_name": "potentially_null_pointer_passed_as_argument", "function_code": "void potentially_null_pointer_passed_as_argument() {\n  int* p = NULL;\n  p = (int*)malloc(sizeof(int));\n  assign(p, 42); // NULL dereference\n  free(p);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void assign(int* p, int n) { *p = n; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 74, "severity": "ERROR", "trace": "in call to `malloc (null case)` (modelled),is assigned to the null pointer,assigned,when calling `assign` here,parameter `p` of assign,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 71, "end_line": 76}}
{"id": "nullptr_more_010", "source_file": "pulse/nullptr_more.c", "original_function_name": "null_passed_as_argument_bad", "anonymized_function_name": "null_passed_as_argument", "function_code": "void null_passed_as_argument() {\n  assign(NULL, 42); // NULL dereference\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void assign(int* p, int n) { *p = n; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 1, "absolute_line": 79, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `assign` here,parameter `p` of assign,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 78, "end_line": 80}}
{"id": "nullptr_more_011", "source_file": "pulse/nullptr_more.c", "original_function_name": "allocated_pointer_passed_as_argument_ok", "anonymized_function_name": "allocated_pointer_passed_as_argument", "function_code": "void allocated_pointer_passed_as_argument() {\n  int* p = NULL;\n  p = (int*)malloc(sizeof(int));\n  if (p) {\n    assign(p, 42);\n    free(p);\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void assign(int* p, int n) { *p = n; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 82, "end_line": 89}}
{"id": "nullptr_more_012", "source_file": "pulse/nullptr_more.c", "original_function_name": "unsafe_allocate", "anonymized_function_name": "unsafe_allocate", "function_code": "int* unsafe_allocate() {\n  int* p = NULL;\n  p = (int*)malloc(sizeof(int));\n  return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 91, "end_line": 95}}
{"id": "nullptr_more_013", "source_file": "pulse/nullptr_more.c", "original_function_name": "safe_allocate", "anonymized_function_name": "safe_allocate", "function_code": "int* safe_allocate() {\n  int* p = NULL;\n  while (!p) {\n    p = (int*)malloc(sizeof(int));\n  }\n  return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_LOOP", "line_offset": 2, "absolute_line": 99, "severity": "WARNING", "trace": "in loop"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 97, "end_line": 103}}
{"id": "nullptr_more_014", "source_file": "pulse/nullptr_more.c", "original_function_name": "function_call_can_return_null_pointer_bad", "anonymized_function_name": "function_call_can_return_null_pointer", "function_code": "void function_call_can_return_null_pointer() {\n  int* p = NULL;\n  p = unsafe_allocate();\n  assign(p, 42); // NULL dereference\n  free(p);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void assign(int* p, int n) { *p = n; }\n", "int* unsafe_allocate() {\n  int* p = NULL;\n  p = (int*)malloc(sizeof(int));\n  return p;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 108, "severity": "ERROR", "trace": "in call to `unsafe_allocate`,in call to `malloc (null case)` (modelled),is assigned to the null pointer,assigned,returned,return from call to `unsafe_allocate`,assigned,when calling `assign` here,parameter `p` of assign,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 105, "end_line": 110}}
{"id": "nullptr_more_015", "source_file": "pulse/nullptr_more.c", "original_function_name": "function_call_returns_allocated_pointer_ok", "anonymized_function_name": "function_call_returns_allocated_pointer", "function_code": "void function_call_returns_allocated_pointer() {\n  int* p = NULL;\n  p = safe_allocate();\n  assign(p, 42);\n  free(p);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void assign(int* p, int n) { *p = n; }\n", "int* safe_allocate() {\n  int* p = NULL;\n  while (!p) {\n    p = (int*)malloc(sizeof(int));\n  }\n  return p;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 112, "end_line": 117}}
{"id": "nullptr_more_016", "source_file": "pulse/nullptr_more.c", "original_function_name": "sizeof_expr_ok", "anonymized_function_name": "sizeof_expr", "function_code": "void sizeof_expr(void) {\n  struct Person* p = malloc(sizeof *p);\n  if (p) {\n    p->age = 42;\n  }\n  free(p);\n}\n", "includes": ["#include <stdlib.h>", "struct Person {\n  int age;\n  int height;\n  int weight;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 119, "end_line": 125}}
{"id": "nullptr_more_017", "source_file": "pulse/nullptr_more.c", "original_function_name": "unreachable_null_ok", "anonymized_function_name": "unreachable_null", "function_code": "void unreachable_null() {\n  int* p = NULL;\n  if (p == NULL) {\n    will_not_return();\n  }\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 129, "end_line": 135}}
{"id": "nullptr_more_018", "source_file": "pulse/nullptr_more.c", "original_function_name": "no_ret", "anonymized_function_name": "no_ret", "function_code": "void no_ret() { will_not_return(); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 137, "end_line": 137}}
{"id": "nullptr_more_019", "source_file": "pulse/nullptr_more.c", "original_function_name": "unreachable_null_no_return_ok", "anonymized_function_name": "unreachable_null_no_return", "function_code": "void unreachable_null_no_return() {\n  int* p = NULL;\n  if (p == NULL) {\n    no_ret(); // inter-procedural call to no_return\n  }\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["void no_ret() { will_not_return(); }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 139, "end_line": 145}}
{"id": "offsetof_expr_001", "source_file": "pulse/offsetof_expr.c", "original_function_name": "test_offsetof_expr_bad", "anonymized_function_name": "test_offsetof_expr", "function_code": "int test_offsetof_expr() {\n  int i = offsetof(struct address, v2);\n  if (i == 2) {\n    int* p = NULL;\n    *p = 42;\n  }\n  return 42;\n}\n", "includes": ["#include <stddef.h>", "#include <stdlib.h>", "struct address {\n  char v1[2];\n  char v2[5];\n  int v3;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 21, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 17, "end_line": 24}}
{"id": "pthread_create_001", "source_file": "pulse/pthread_create.c", "original_function_name": "dummy", "anonymized_function_name": "dummy", "function_code": "void dummy() {}\n", "includes": ["#include <pthread.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 9, "end_line": 9}}
{"id": "pthread_create_002", "source_file": "pulse/pthread_create.c", "original_function_name": "deref_pointer", "anonymized_function_name": "deref_pointer", "function_code": "void deref_pointer(int* x) { int y = *x; }\n", "includes": ["#include <pthread.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 11, "end_line": 11}}
{"id": "pthread_create_003", "source_file": "pulse/pthread_create.c", "original_function_name": "pthread_create_dummy_ok", "anonymized_function_name": "pthread_create_dummy", "function_code": "int pthread_create_dummy() {\n  pthread_t thread;\n  return pthread_create(&thread, NULL, dummy, NULL);\n}\n", "includes": ["#include <pthread.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 13, "end_line": 16}}
{"id": "pthread_create_004", "source_file": "pulse/pthread_create.c", "original_function_name": "pthread_create_deref_ok", "anonymized_function_name": "pthread_create_deref", "function_code": "int pthread_create_deref() {\n  pthread_t thread;\n  int x;\n  return pthread_create(&thread, NULL, deref_pointer, &x);\n}\n", "includes": ["#include <pthread.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 23, "end_line": 27}}
{"id": "pthread_create_005", "source_file": "pulse/pthread_create.c", "original_function_name": "pthread_unknown_ok", "anonymized_function_name": "pthread_unknown", "function_code": "int pthread_unknown() {\n  pthread_t thread;\n  return pthread_create(&thread, NULL, some_unknown_function, NULL);\n}\n", "includes": ["#include <pthread.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 31, "end_line": 34}}
{"id": "pthread_mutex_001", "source_file": "pulse/pthread_mutex.c", "original_function_name": "normal_life_ok", "anonymized_function_name": "normal_life", "function_code": "int normal_life(pthread_mutex_t* m) {\n  if (pthread_mutex_init(m, 0))\n    return 0;\n  if (pthread_mutex_lock(m))\n    return 0;\n  if (pthread_mutex_unlock(m))\n    return 0;\n  if (pthread_mutex_destroy(m))\n    return 0;\n  return 1;\n}\n", "includes": ["#include <pthread.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 9, "end_line": 19}}
{"id": "pthread_mutex_002", "source_file": "pulse/pthread_mutex.c", "original_function_name": "normal_ok2", "anonymized_function_name": "normal_ok2", "function_code": "int normal_ok2() {\n  pthread_mutex_t m;\n  normal_life_ok(&m);\n}\n", "includes": ["#include <pthread.h>"], "dependencies": ["int normal_life_ok(pthread_mutex_t* m) {\n  if (pthread_mutex_init(m, 0))\n    return 0;\n  if (pthread_mutex_lock(m))\n    return 0;\n  if (pthread_mutex_unlock(m))\n    return 0;\n  if (pthread_mutex_destroy(m))\n    return 0;\n  return 1;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 21, "end_line": 24}}
{"id": "pthread_mutex_003", "source_file": "pulse/pthread_mutex.c", "original_function_name": "double_lock_bad2", "anonymized_function_name": "double_lock_bad2", "function_code": "void double_lock_bad2() {\n  pthread_mutex_t m;\n  pthread_mutex_init(&m, 0);\n  FN_double_lock_bad(&m);\n}\n", "includes": ["#include <pthread.h>"], "dependencies": ["void FN_double_lock_bad(pthread_mutex_t* m) {\n  pthread_mutex_lock(m);\n  pthread_mutex_lock(m);\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 36, "end_line": 40}}
{"id": "pthread_mutex_004", "source_file": "pulse/pthread_mutex.c", "original_function_name": "double_init_ok", "anonymized_function_name": "double_init", "function_code": "void double_init() {\n  pthread_mutex_t m;\n  double_init_bad(&m);\n}\n", "includes": ["#include <pthread.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 60, "end_line": 63}}
{"id": "recursion_001", "source_file": "pulse/recursion.c", "original_function_name": "trivial_recursive_bad", "anonymized_function_name": "trivial_recursive", "function_code": "void trivial_recursive() { trivial_recursive(); }\n", "includes": ["#include \"recursion2.h\""], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 12, "severity": "WARNING", "trace": "`trivial_recursive_bad` makes a recursive call to `trivial_recursive_bad` with the same argument values"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 12, "end_line": 12}}
{"id": "recursion_002", "source_file": "pulse/recursion.c", "original_function_name": "factorial_bad", "anonymized_function_name": "factorial", "function_code": "int factorial(int x) {\n  if (x > 0) {\n    return x * factorial(x - 1);\n  } else {\n    return 1;\n  }\n}\n", "includes": ["#include \"recursion2.h\""], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MUTUAL_RECURSION_CYCLE", "line_offset": 2, "absolute_line": 16, "severity": "WARNING", "trace": "`factorial_bad` makes a recursive call to `factorial_bad`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 14, "end_line": 20}}
{"id": "recursion_003", "source_file": "pulse/recursion.c", "original_function_name": "mutual3_bad", "anonymized_function_name": "mutual3", "function_code": "void mutual3() { mutual1_bad(); }\n", "includes": ["#include \"recursion2.h\""], "dependencies": ["void mutual1_bad() { mutual2_bad(); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 24, "severity": "WARNING", "trace": "`mutual3_bad` calls `mutual1_bad`,`mutual1_bad` calls `mutual2_bad`,`mutual2_bad` makes a recursive call to `mutual3_bad` with the same argument values"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 24, "end_line": 24}}
{"id": "recursion_004", "source_file": "pulse/recursion.c", "original_function_name": "mutual2_bad", "anonymized_function_name": "mutual2", "function_code": "void mutual2() { mutual3_bad(); }\n", "includes": ["#include \"recursion2.h\""], "dependencies": ["void mutual3_bad() { mutual1_bad(); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 26, "severity": "WARNING", "trace": "`mutual2_bad` calls `mutual3_bad`,`mutual3_bad` calls `mutual1_bad`,`mutual1_bad` makes a recursive call to `mutual2_bad` with the same argument values"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 26, "end_line": 26}}
{"id": "recursion_005", "source_file": "pulse/recursion.c", "original_function_name": "mutual1_bad", "anonymized_function_name": "mutual1", "function_code": "void mutual1() { mutual2_bad(); }\n", "includes": ["#include \"recursion2.h\""], "dependencies": ["void mutual2_bad() { mutual3_bad(); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 28, "severity": "WARNING", "trace": "`mutual1_bad` calls `mutual2_bad`,`mutual2_bad` calls `mutual3_bad`,`mutual3_bad` makes a recursive call to `mutual1_bad` with the same argument values"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 28, "end_line": 28}}
{"id": "recursion_006", "source_file": "pulse/recursion.c", "original_function_name": "recursive_modify_global_ok", "anonymized_function_name": "recursive_modify_global", "function_code": "void recursive_modify_global(int x) {\n  if (global > 0) {\n    global--;\n    recursive_modify_global(x);\n  }\n}\n", "includes": ["#include \"recursion2.h\""], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MUTUAL_RECURSION_CYCLE", "line_offset": 3, "absolute_line": 36, "severity": "WARNING", "trace": "`recursive_modify_global_ok` makes a recursive call to `recursive_modify_global_ok`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 33, "end_line": 38}}
{"id": "recursion_007", "source_file": "pulse/recursion.c", "original_function_name": "infinite_recursion_unchanged_global_bad", "anonymized_function_name": "infinite_recursion_unchanged_global", "function_code": "void infinite_recursion_unchanged_global(int x) {\n  if (global > 0) {\n    global = global;\n    infinite_recursion_unchanged_global(x);\n  }\n}\n", "includes": ["#include \"recursion2.h\""], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 3, "absolute_line": 43, "severity": "WARNING", "trace": "`infinite_recursion_unchanged_global_bad` makes a recursive call to `infinite_recursion_unchanged_global_bad` with the same argument values"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 40, "end_line": 45}}
{"id": "recursion_008", "source_file": "pulse/recursion.c", "original_function_name": "fp_recursion_on_field_ok", "anonymized_function_name": "fp_recursion_on_field", "function_code": "void fp_recursion_on_field(struct data* x) {\n  if (x->a > 0) {\n    x->a = x->a - 1;\n    fp_recursion_on_field(x);\n  }\n}\n", "includes": ["#include \"recursion2.h\"", "struct data {\n  int a;\n  int b;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 3, "absolute_line": 57, "severity": "WARNING", "trace": "`fp_recursion_on_field_ok` makes a recursive call to `fp_recursion_on_field_ok` with the same argument values"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 54, "end_line": 59}}
{"id": "recursion_009", "source_file": "pulse/recursion.c", "original_function_name": "set_fields", "anonymized_function_name": "set_fields", "function_code": "void set_fields(struct data* x, int a, int b) {\n  x->b = b;\n  x->a = a;\n}\n", "includes": ["#include \"recursion2.h\"", "struct data {\n  int a;\n  int b;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 61, "end_line": 64}}
{"id": "recursion_010", "source_file": "pulse/recursion.c", "original_function_name": "recursion_on_fields_bad", "anonymized_function_name": "recursion_on_fields", "function_code": "void recursion_on_fields(struct data* x) {\n  // materialize fields of x in the order \"a, b\" in the pre\n  int a = x->a;\n  int b = x->b;\n  // trick pulse into writing the fields of x in the order \"b, a\" in the post\n  set_fields(x, a, b);\n  recursion_on_fields(x);\n}\n", "includes": ["#include \"recursion2.h\"", "struct data {\n  int a;\n  int b;\n};"], "dependencies": ["void set_fields(struct data* x, int a, int b) {\n  x->b = b;\n  x->a = a;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 6, "absolute_line": 72, "severity": "WARNING", "trace": "`recursion_on_fields_bad` makes a recursive call to `recursion_on_fields_bad` with the same argument values"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 66, "end_line": 73}}
{"id": "recursion_011", "source_file": "pulse/recursion.c", "original_function_name": "across_file_1", "anonymized_function_name": "across_file_1", "function_code": "void across_file_1() { across_file_2(); }\n", "includes": ["#include \"recursion2.h\""], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 77, "severity": "WARNING", "trace": "`across_file_1` calls `across_file_2`,`across_file_2` makes a recursive call to `across_file_1` with the same argument values"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 77, "end_line": 77}}
{"id": "recursion2_001", "source_file": "pulse/recursion2.c", "original_function_name": "across_file_2", "anonymized_function_name": "across_file_2", "function_code": "void across_file_2() { across_file_1(); }\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "INFINITE_RECURSION", "line_offset": 0, "absolute_line": 10, "severity": "WARNING", "trace": "`across_file_2` calls `across_file_1`,`across_file_1` makes a recursive call to `across_file_2` with the same argument values"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 10, "end_line": 10}}
{"id": "resource_leak_001", "source_file": "pulse/resource_leak.c", "original_function_name": "fileNotClosed_bad", "anonymized_function_name": "fileNotClosed", "function_code": "void fileNotClosed() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    char buffer[256];\n    write(fd, buffer, strlen(buffer));\n  }\n}\n", "includes": ["#include <errno.h>", "#include <fcntl.h>", "#include <stdbool.h>", "#include <stdint.h>", "#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "#include <sys/select.h>", "#include <sys/socket.h>", "#include <sys/stat.h>", "#include <sys/types.h>", "#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_RESOURCE_LEAK", "line_offset": 4, "absolute_line": 25, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `fopen()` here,file descriptor becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "resource_leak", "start_line": 21, "end_line": 27}}
{"id": "resource_leak_002", "source_file": "pulse/resource_leak.c", "original_function_name": "fileClosed_ok", "anonymized_function_name": "fileClosed", "function_code": "void fileClosed() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    char buffer[256];\n    write(fd, buffer, strlen(buffer));\n    close(fd);\n  }\n}\n", "includes": ["#include <errno.h>", "#include <fcntl.h>", "#include <stdbool.h>", "#include <stdint.h>", "#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "#include <sys/select.h>", "#include <sys/socket.h>", "#include <sys/stat.h>", "#include <sys/types.h>", "#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 29, "end_line": 36}}
{"id": "resource_leak_003", "source_file": "pulse/resource_leak.c", "original_function_name": "fdopen_to_global_ok", "anonymized_function_name": "fdopen_to_global", "function_code": "void fdopen_to_global() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    handler = fdopen(fd, \"w\");\n    fclose(handler);\n  }\n}\n", "includes": ["#include <errno.h>", "#include <fcntl.h>", "#include <stdbool.h>", "#include <stdint.h>", "#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "#include <sys/select.h>", "#include <sys/socket.h>", "#include <sys/stat.h>", "#include <sys/types.h>", "#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 40, "end_line": 46}}
{"id": "resource_leak_004", "source_file": "pulse/resource_leak.c", "original_function_name": "gzdopen_to_global_ok", "anonymized_function_name": "gzdopen_to_global", "function_code": "void gzdopen_to_global() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    handler = gzdopen(fd, \"w\");\n    fclose(handler);\n  }\n}\n", "includes": ["#include <errno.h>", "#include <fcntl.h>", "#include <stdbool.h>", "#include <stdint.h>", "#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "#include <sys/select.h>", "#include <sys/socket.h>", "#include <sys/stat.h>", "#include <sys/types.h>", "#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 48, "end_line": 54}}
{"id": "resource_leak_005", "source_file": "pulse/resource_leak.c", "original_function_name": "socketNotClosed_bad", "anonymized_function_name": "socketNotClosed", "function_code": "void socketNotClosed() {\n  int fd = socket(AF_LOCAL, SOCK_RAW, 0);\n  if (fd != -1) {\n    char buffer[256];\n    write(fd, buffer, strlen(buffer));\n  }\n}\n", "includes": ["#include <errno.h>", "#include <fcntl.h>", "#include <stdbool.h>", "#include <stdint.h>", "#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "#include <sys/select.h>", "#include <sys/socket.h>", "#include <sys/stat.h>", "#include <sys/types.h>", "#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_RESOURCE_LEAK", "line_offset": 4, "absolute_line": 60, "severity": "ERROR", "trace": "allocation part of the trace starts here,allocated by `fopen()` here,file descriptor becomes unreachable here"}]}, "metadata": {"requires_interprocedural": false, "category": "resource_leak", "start_line": 56, "end_line": 62}}
{"id": "resource_leak_006", "source_file": "pulse/resource_leak.c", "original_function_name": "socketClosed_ok", "anonymized_function_name": "socketClosed", "function_code": "int socketClosed() {\n  int socketFD = socket(AF_LOCAL, SOCK_RAW, 0);\n  if (socketFD == -1) {\n    return -1;\n  }\n\n  int status;\n\n  status = fcntl(socketFD, F_SETFL, O_NONBLOCK);\n  if (status == -1) {\n    close(socketFD);\n    return -1;\n  }\n\n  int reuseaddr = 1;\n  status = setsockopt(\n      socketFD, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));\n  if (status == -1) {\n    close(socketFD);\n    return -1;\n  }\n\n  int nosigpipe = 1;\n  status = setsockopt(\n      socketFD, SOL_SOCKET, SO_REUSEADDR, &nosigpipe, sizeof(nosigpipe));\n  if (status == -1) {\n    close(socketFD);\n    return -1;\n  }\n\n  return socketFD;\n}\n", "includes": ["#include <errno.h>", "#include <fcntl.h>", "#include <stdbool.h>", "#include <stdint.h>", "#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "#include <sys/select.h>", "#include <sys/socket.h>", "#include <sys/stat.h>", "#include <sys/types.h>", "#include <unistd.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 64, "end_line": 95}}
{"id": "sentinel_attribute_001", "source_file": "pulse/sentinel_attribute.c", "original_function_name": "valid_call_ok", "anonymized_function_name": "valid_call", "function_code": "void valid_call(int* a, int* b, int* c) {\n  // fine\n  int x = add_all_ints(0, 0, 0, a, b, c, NULL);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 12, "end_line": 15}}
{"id": "shift_001", "source_file": "pulse/shift.c", "original_function_name": "return_depends_on_lshift", "anonymized_function_name": "return_depends_on_lshift", "function_code": "int* return_depends_on_lshift(int x, int* p) {\n  if (x < (1 << 7))\n    return NULL;\n  else\n    return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 10, "end_line": 15}}
{"id": "shift_002", "source_file": "pulse/shift.c", "original_function_name": "return_nonnull_deref1_ok", "anonymized_function_name": "return_nonnull_deref1", "function_code": "int return_nonnull_deref1() {\n  int y = 0;\n  return *return_depends_on_lshift(1000, &y);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* return_depends_on_lshift(int x, int* p) {\n  if (x < (1 << 7))\n    return NULL;\n  else\n    return p;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 17, "end_line": 20}}
{"id": "shift_003", "source_file": "pulse/shift.c", "original_function_name": "return_null_deref1_bad", "anonymized_function_name": "return_null_deref1", "function_code": "int return_null_deref1() {\n  int y = 0;\n  return *return_depends_on_lshift(0, &y);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* return_depends_on_lshift(int x, int* p) {\n  if (x < (1 << 7))\n    return NULL;\n  else\n    return p;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 24, "severity": "ERROR", "trace": "in call to `return_depends_on_lshift`,is assigned to the null pointer,returned,return from call to `return_depends_on_lshift`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 22, "end_line": 25}}
{"id": "shift_004", "source_file": "pulse/shift.c", "original_function_name": "return_depends_on_rshift", "anonymized_function_name": "return_depends_on_rshift", "function_code": "int* return_depends_on_rshift(int x, int* p) {\n  if (x < (4 >> 2))\n    return NULL;\n  else\n    return p;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 27, "end_line": 32}}
{"id": "shift_005", "source_file": "pulse/shift.c", "original_function_name": "return_nonnull_deref2_ok", "anonymized_function_name": "return_nonnull_deref2", "function_code": "int return_nonnull_deref2() {\n  int y = 0;\n  return *return_depends_on_rshift(2, &y);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* return_depends_on_rshift(int x, int* p) {\n  if (x < (4 >> 2))\n    return NULL;\n  else\n    return p;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 34, "end_line": 37}}
{"id": "shift_006", "source_file": "pulse/shift.c", "original_function_name": "return_null_deref2_bad", "anonymized_function_name": "return_null_deref2", "function_code": "int return_null_deref2() {\n  int y = 0;\n  return *return_depends_on_rshift(0, &y);\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int* return_depends_on_rshift(int x, int* p) {\n  if (x < (4 >> 2))\n    return NULL;\n  else\n    return p;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 41, "severity": "ERROR", "trace": "in call to `return_depends_on_rshift`,is assigned to the null pointer,returned,return from call to `return_depends_on_rshift`,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 39, "end_line": 42}}
{"id": "sizeof_001", "source_file": "pulse/sizeof.c", "original_function_name": "sizeof_eval_ok", "anonymized_function_name": "sizeof_eval", "function_code": "int sizeof_eval(void) {\n  int a = 4;\n  int b = sizeof(a);\n  char c[2];\n\n  if (a % 4) { // 4 % 4 = 0\n    int* p = NULL;\n    *p = 42;\n  }\n  if (b % sizeof(a)) { // x % x = 0\n    int* p = NULL;\n    *p = 42;\n  }\n  if (sizeof(c) > 2) { // 2 > 2 is false\n    int* p = NULL;\n    *p = 42;\n  }\n  if ((sizeof(c) / sizeof(c[0])) != 2) { // (2 / 1) = 2\n    int* p = NULL;\n    *p = 42;\n  }\n  return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 10, "end_line": 32}}
{"id": "specialization_001", "source_file": "pulse/specialization.c", "original_function_name": "id", "anonymized_function_name": "id", "function_code": "int id(int i) { return i; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 12, "end_line": 12}}
{"id": "specialization_002", "source_file": "pulse/specialization.c", "original_function_name": "add_one", "anonymized_function_name": "add_one", "function_code": "int add_one(int i) { return invoke(id, i) + 1; }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 14, "end_line": 14}}
{"id": "specialization_003", "source_file": "pulse/specialization.c", "original_function_name": "add_two", "anonymized_function_name": "add_two", "function_code": "int add_two(int i) {\n  int one = invoke(id, 1);\n  add_one(0);\n  return invoke(add_one, i) + 1;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int add_one(int i) { return invoke(id, i) + 1; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 16, "end_line": 20}}
{"id": "specialization_004", "source_file": "pulse/specialization.c", "original_function_name": "add_more_bad", "anonymized_function_name": "add_more", "function_code": "int add_more(int i) {\n  if (i > 0) {\n    return invoke(add_more, i - 1) + 1;\n  }\n  return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MUTUAL_RECURSION_CYCLE", "line_offset": 2, "absolute_line": 25, "severity": "WARNING", "trace": "`add_more_bad` calls `invoke`,`invoke` makes a recursive call to `add_more_bad`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 23, "end_line": 28}}
{"id": "specialization_005", "source_file": "pulse/specialization.c", "original_function_name": "test_invoke_ok", "anonymized_function_name": "test_invoke", "function_code": "void test_invoke() {\n  if (add_one(0) != 1) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int add_one(int i) { return invoke(id, i) + 1; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 30, "end_line": 35}}
{"id": "specialization_006", "source_file": "pulse/specialization.c", "original_function_name": "test_invoke_bad", "anonymized_function_name": "test_invoke", "function_code": "void test_invoke() {\n  if (add_one(0) == 1) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int add_one(int i) { return invoke(id, i) + 1; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 40, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 37, "end_line": 42}}
{"id": "specialization_007", "source_file": "pulse/specialization.c", "original_function_name": "test_recursive_invoke_ok", "anonymized_function_name": "test_recursive_invoke", "function_code": "void test_recursive_invoke() {\n  if (add_two(0) + add_one(0) != 3) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int add_one(int i) { return invoke(id, i) + 1; }\n", "int add_two(int i) {\n  int one = invoke(id, 1);\n  add_one(0);\n  return invoke(add_one, i) + 1;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 44, "end_line": 49}}
{"id": "specialization_008", "source_file": "pulse/specialization.c", "original_function_name": "test_recursive_invoke_bad", "anonymized_function_name": "test_recursive_invoke", "function_code": "void test_recursive_invoke() {\n  if (add_two(0) + add_one(0) == 3) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int add_one(int i) { return invoke(id, i) + 1; }\n", "int add_two(int i) {\n  int one = invoke(id, 1);\n  add_one(0);\n  return invoke(add_one, i) + 1;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 54, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 51, "end_line": 56}}
{"id": "specialization_009", "source_file": "pulse/specialization.c", "original_function_name": "two_pointers_recursion_bad", "anonymized_function_name": "two_pointers_recursion", "function_code": "int two_pointers_recursion(int* x, int* y, int i) {\n  if (i > 0) {\n    return *x + *y + two_pointers_recursion(x, x, i - 1);\n  }\n  return 0;\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "MUTUAL_RECURSION_CYCLE", "line_offset": 2, "absolute_line": 61, "severity": "WARNING", "trace": "`two_pointers_recursion_bad` makes a recursive call to `two_pointers_recursion_bad`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 59, "end_line": 64}}
{"id": "specialization_010", "source_file": "pulse/specialization.c", "original_function_name": "alias_recursion", "anonymized_function_name": "alias_recursion", "function_code": "void alias_recursion(int* z) { two_pointers_recursion_bad(z, z, 10); }\n", "includes": ["#include <stdlib.h>"], "dependencies": ["int two_pointers_recursion_bad(int* x, int* y, int i) {\n  if (i > 0) {\n    return *x + *y + two_pointers_recursion_bad(x, x, i - 1);\n  }\n  return 0;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 66, "end_line": 66}}
{"id": "specialization_011", "source_file": "pulse/specialization.c", "original_function_name": "specialize_invoke_itself_ok", "anonymized_function_name": "specialize_invoke_itself", "function_code": "void specialize_invoke_itself() { invoke_itself_bad(id, 10); }\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 76, "end_line": 76}}
{"id": "struct_values_001", "source_file": "pulse/struct_values.c", "original_function_name": "changes_fields_locally", "anonymized_function_name": "changes_fields_locally", "function_code": "void changes_fields_locally(struct s a) {\n  int u = a.i.x;\n  a.f = 42;\n  a.i.y = 15;\n}\n", "includes": ["#include <stdlib.h>", "struct s {\n  struct inlined i;\n  int f;\n  int g;\n};", "struct inlined {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 21, "end_line": 25}}
{"id": "struct_values_002", "source_file": "pulse/struct_values.c", "original_function_name": "struct_value_in_callee_ok", "anonymized_function_name": "struct_value_in_callee", "function_code": "void struct_value_in_callee() {\n  struct s b = {{11, 22}, 33, 44};\n  changes_fields_locally(b);\n  if (b.i.x != 11 || b.i.y != 22 || b.f != 33 || b.g != 44) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct s {\n  struct inlined i;\n  int f;\n  int g;\n};", "struct inlined {\n  int x;\n  int y;\n};"], "dependencies": ["void changes_fields_locally(struct s a) {\n  int u = a.i.x;\n  a.f = 42;\n  a.i.y = 15;\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 27, "end_line": 34}}
{"id": "taint_var_arg_001", "source_file": "pulse/taint_var_arg.c", "original_function_name": "printf_source_bad1", "anonymized_function_name": "printf_source_bad1", "function_code": "void printf_source_bad1() { printf(\"Integers: %i %u \\n\", -3456, int_source()); }\n", "includes": ["#include <stdio.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 0, "absolute_line": 13, "severity": "ERROR", "trace": "source of the taint here: value returned from `int_source` with kind `Simple`,flows to this sink: value passed as argument `#2` to `printf` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 13, "end_line": 13}}
{"id": "taint_var_arg_002", "source_file": "pulse/taint_var_arg.c", "original_function_name": "printf_source_bad2", "anonymized_function_name": "printf_source_bad2", "function_code": "void printf_source_bad2() {\n  printf(\"Some different radices: %d %x %o %#x %#o \\n\",\n         100,\n         int_source(),\n         100,\n         100,\n         100);\n}\n", "includes": ["#include <stdio.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 1, "absolute_line": 16, "severity": "ERROR", "trace": "source of the taint here: value returned from `int_source` with kind `Simple`,flows to this sink: value passed as argument `#2` to `printf` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 15, "end_line": 22}}
{"id": "taint_var_arg_003", "source_file": "pulse/taint_var_arg.c", "original_function_name": "printf_source_bad3", "anonymized_function_name": "printf_source_bad3", "function_code": "void printf_source_bad3() {\n  printf(\"floats: %4.2f %+.0e %E \\n\", 3.14159, 3.14159, float_source());\n}\n", "includes": ["#include <stdio.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 1, "absolute_line": 25, "severity": "ERROR", "trace": "source of the taint here: value returned from `float_source` with kind `Simple`,flows to this sink: value passed as argument `#3` to `printf` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 24, "end_line": 26}}
{"id": "taint_var_arg_004", "source_file": "pulse/taint_var_arg.c", "original_function_name": "printf_source_bad4", "anonymized_function_name": "printf_source_bad4", "function_code": "void printf_source_bad4() {\n  printf(\"Preceding with zeros: %010d \\n\", int_source());\n}\n", "includes": ["#include <stdio.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "TAINT_ERROR", "line_offset": 1, "absolute_line": 29, "severity": "ERROR", "trace": "source of the taint here: value returned from `int_source` with kind `Simple`,flows to this sink: value passed as argument `#1` to `printf` with kind `Simple`"}]}, "metadata": {"requires_interprocedural": false, "category": "other", "start_line": 28, "end_line": 30}}
{"id": "ternary_001", "source_file": "pulse/ternary.c", "original_function_name": "ternary1_ok", "anonymized_function_name": "ternary1", "function_code": "int ternary1(int x) {\n  struct data* p = x ? &d : 0;\n  return (p && p->flag);\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 14, "end_line": 17}}
{"id": "ternary_002", "source_file": "pulse/ternary.c", "original_function_name": "ternary2_bad", "anonymized_function_name": "ternary2", "function_code": "int ternary2(int x) {\n  struct data* p = x ? &d : 0;\n  return p->flag && p; // NULL_DEREF\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 21, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 19, "end_line": 22}}
{"id": "ternary_003", "source_file": "pulse/ternary.c", "original_function_name": "ternary3_ok", "anonymized_function_name": "ternary3", "function_code": "int ternary3(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p && p->flag); // OK\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 24, "end_line": 27}}
{"id": "ternary_004", "source_file": "pulse/ternary.c", "original_function_name": "ternary4_ok", "anonymized_function_name": "ternary4", "function_code": "int ternary4(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p && p->flag); // OK\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 29, "end_line": 32}}
{"id": "ternary_005", "source_file": "pulse/ternary.c", "original_function_name": "ternary4_bad", "anonymized_function_name": "ternary4", "function_code": "int ternary4(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p->flag && p); // NULL_DEREF\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 36, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 34, "end_line": 37}}
{"id": "ternary_006", "source_file": "pulse/ternary.c", "original_function_name": "ternary5_ok", "anonymized_function_name": "ternary5", "function_code": "int ternary5(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p && p->flag); // OK\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 39, "end_line": 42}}
{"id": "ternary_007", "source_file": "pulse/ternary.c", "original_function_name": "ternary6_ok", "anonymized_function_name": "ternary6", "function_code": "int ternary6(int x) {\n  struct data* p = x ? &d : 0;\n  return !p || p->flag; // OK\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 44, "end_line": 47}}
{"id": "ternary_008", "source_file": "pulse/ternary.c", "original_function_name": "ternary7_bad", "anonymized_function_name": "ternary7", "function_code": "int ternary7(int x) {\n  struct data* p = x ? &d : 0;\n  return p || p->flag; // NULL_DEREF\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 51, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 49, "end_line": 52}}
{"id": "ternary_009", "source_file": "pulse/ternary.c", "original_function_name": "ternary8_ok", "anonymized_function_name": "ternary8", "function_code": "int ternary8(int x) {\n  struct data* p = x ? &d : 0;\n  return (!p || p->flag) && !(p && p->flag); // OK\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 54, "end_line": 57}}
{"id": "ternary_010", "source_file": "pulse/ternary.c", "original_function_name": "ternary9_ok", "anonymized_function_name": "ternary9", "function_code": "int ternary9(int x) {\n  struct data* p = x ? &d : 0;\n  return p && (p->flag || !(p->flag)); // OK\n}\n", "includes": ["struct data {\n  int flag;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 59, "end_line": 62}}
{"id": "traces_001", "source_file": "pulse/traces.c", "original_function_name": "simple_deref", "anonymized_function_name": "simple_deref", "function_code": "void simple_deref() {\n  int* p = NULL;\n  int* q = p; // this line should not be part of the trace\n  *p = 42;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdint.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 14, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 11, "end_line": 15}}
{"id": "traces_002", "source_file": "pulse/traces.c", "original_function_name": "simple_deref_via_alias", "anonymized_function_name": "simple_deref_via_alias", "function_code": "void simple_deref_via_alias() {\n  int* p = NULL;\n  int* q = p;\n  *q = 42;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdint.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 20, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 17, "end_line": 21}}
{"id": "traces_003", "source_file": "pulse/traces.c", "original_function_name": "call_makes_null_deref_manifest_bad", "anonymized_function_name": "call_makes_null_deref_manifest", "function_code": "void call_makes_null_deref_manifest() {\n  uint16_t utf16String;\n  uint8_t* utf8String;\n  size_t utf8StringLen;\n  something_about_strings_latent(&utf16String, 0, &utf8String, &utf8StringLen);\n  free(utf8String);\n}\n", "includes": ["#include <stdlib.h>", "#include <stdint.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 46, "severity": "ERROR", "trace": "is assigned to the null pointer,when calling `something_about_strings_latent` here,in call to `malloc (null case)` (modelled),is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 42, "end_line": 48}}
{"id": "traces_004", "source_file": "pulse/traces.c", "original_function_name": "access_null_deref_bad", "anonymized_function_name": "access_null_deref", "function_code": "void access_null_deref() {\n  struct list l = {NULL, 44};\n  l.next->next = NULL;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdint.h>", "struct list {\n  struct list* next;\n  int data;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 57, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 55, "end_line": 58}}
{"id": "traces_005", "source_file": "pulse/traces.c", "original_function_name": "access_use_after_free_bad", "anonymized_function_name": "access_use_after_free", "function_code": "void access_use_after_free(struct list* l) {\n  free(l->next);\n  l->next->next = NULL;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdint.h>", "struct list {\n  struct list* next;\n  int data;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 2, "absolute_line": 62, "severity": "ERROR", "trace": "*** SUPPRESSED ***,source of the null value part of the trace starts here,assigned,is assigned to the null pointer,null pointer dereference part of the trace starts here,parameter `l` of access_use_after_free_bad,invalid access occurs here"}, {"bug_type": "USE_AFTER_FREE", "line_offset": 2, "absolute_line": 62, "severity": "ERROR", "trace": "invalidation part of the trace starts here,parameter `l` of access_use_after_free_bad,was invalidated by call to `free()`,use-after-lifetime part of the trace starts here,parameter `l` of access_use_after_free_bad,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 60, "end_line": 63}}
{"id": "transitive-access_001", "source_file": "pulse/transitive-access.c", "original_function_name": "sink", "anonymized_function_name": "sink", "function_code": "void sink() {}\n", "includes": [], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 8, "end_line": 8}}
{"id": "transitive-access_002", "source_file": "pulse/transitive-access.c", "original_function_name": "wrapper_ok", "anonymized_function_name": "wrapper", "function_code": "void wrapper() { sink(); }\n", "includes": [], "dependencies": ["void sink() {}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 10, "end_line": 10}}
{"id": "transitive-access_003", "source_file": "pulse/transitive-access.c", "original_function_name": "source_bad", "anonymized_function_name": "source", "function_code": "void source() { wrapper_ok(); }\n", "includes": [], "dependencies": ["void wrapper_ok() { sink(); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_TRANSITIVE_ACCESS", "line_offset": 0, "absolute_line": 12, "severity": "ERROR", "trace": "when calling `wrapper_ok` here,access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "other", "start_line": 12, "end_line": 12}}
{"id": "uninit_001", "source_file": "pulse/uninit.c", "original_function_name": "dereference_bad", "anonymized_function_name": "dereference", "function_code": "int dereference() {\n  int* p;\n  return *p;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 2, "absolute_line": 13, "severity": "ERROR", "trace": "variable `p` declared here,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "uninitialized_value", "start_line": 11, "end_line": 14}}
{"id": "uninit_002", "source_file": "pulse/uninit.c", "original_function_name": "self_assign_bad", "anonymized_function_name": "self_assign", "function_code": "void self_assign() {\n  int x;\n  x = x;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 2, "absolute_line": 18, "severity": "ERROR", "trace": "variable `x` declared here,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "uninitialized_value", "start_line": 16, "end_line": 19}}
{"id": "uninit_003", "source_file": "pulse/uninit.c", "original_function_name": "call_to_use_and_mayinit_bad", "anonymized_function_name": "call_to_use_and_mayinit", "function_code": "void call_to_use_and_mayinit() {\n  int x;\n  use_and_mayinit(x, &x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 2, "absolute_line": 25, "severity": "ERROR", "trace": "variable `x` declared here,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "uninitialized_value", "start_line": 23, "end_line": 26}}
{"id": "uninit_004", "source_file": "pulse/uninit.c", "original_function_name": "malloc_good", "anonymized_function_name": "malloc", "function_code": "void malloc() {\n  int* p = (int*)malloc(sizeof(int));\n  if (p) {\n    *p = 5;\n    int x = *p;\n  }\n  free(p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 28, "end_line": 35}}
{"id": "uninit_005", "source_file": "pulse/uninit.c", "original_function_name": "malloc_bad", "anonymized_function_name": "malloc", "function_code": "void malloc() {\n  int* p = (int*)malloc(sizeof(int));\n  if (p) {\n    int x = *p;\n  }\n  free(p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 40, "severity": "ERROR", "trace": "allocated by call to `malloc` (modelled),assigned,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "uninitialized_value", "start_line": 37, "end_line": 43}}
{"id": "uninit_006", "source_file": "pulse/uninit.c", "original_function_name": "init_int_ref", "anonymized_function_name": "init_int_ref", "function_code": "void init_int_ref(int* p) { *p = 5; }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 45, "end_line": 45}}
{"id": "uninit_007", "source_file": "pulse/uninit.c", "original_function_name": "interprocedural_init_in_callee_good", "anonymized_function_name": "interprocedural_init_in_callee", "function_code": "void interprocedural_init_in_callee() {\n  int x;\n  init_int_ref(&x);\n  int y = x;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void init_int_ref(int* p) { *p = 5; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 47, "end_line": 51}}
{"id": "uninit_008", "source_file": "pulse/uninit.c", "original_function_name": "nop", "anonymized_function_name": "nop", "function_code": "void nop(int* p) {}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 53, "end_line": 53}}
{"id": "uninit_009", "source_file": "pulse/uninit.c", "original_function_name": "interprocedural_nop_in_callee_bad", "anonymized_function_name": "interprocedural_nop_in_callee", "function_code": "void interprocedural_nop_in_callee() {\n  int x;\n  nop(&x);\n  int y = x;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void nop(int* p) {}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 58, "severity": "ERROR", "trace": "variable `x` declared here,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "uninitialized_value", "start_line": 55, "end_line": 59}}
{"id": "uninit_010", "source_file": "pulse/uninit.c", "original_function_name": "read_int_ref", "anonymized_function_name": "read_int_ref", "function_code": "void read_int_ref(int* p) { int x = *p; }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 61, "end_line": 61}}
{"id": "uninit_011", "source_file": "pulse/uninit.c", "original_function_name": "interprocedural_read_in_callee_bad", "anonymized_function_name": "interprocedural_read_in_callee", "function_code": "void interprocedural_read_in_callee() {\n  int x;\n  read_int_ref(&x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void read_int_ref(int* p) { int x = *p; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 2, "absolute_line": 65, "severity": "ERROR", "trace": "variable `x` declared here,when calling `read_int_ref` here,parameter `p` of read_int_ref,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "uninitialized_value", "start_line": 63, "end_line": 66}}
{"id": "uninit_012", "source_file": "pulse/uninit.c", "original_function_name": "uninit", "anonymized_function_name": "uninit", "function_code": "int* uninit() { return (int*)malloc(sizeof(int)); }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 68, "end_line": 68}}
{"id": "uninit_013", "source_file": "pulse/uninit.c", "original_function_name": "interprocedural_uninit_in_callee_bad", "anonymized_function_name": "interprocedural_uninit_in_callee", "function_code": "void interprocedural_uninit_in_callee() {\n  int* p = uninit();\n  if (p) {\n    int x = *p;\n  }\n  free(p);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["int* uninit() { return (int*)malloc(sizeof(int)); }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 73, "severity": "ERROR", "trace": "in call to `uninit`,allocated by call to `malloc` (modelled),returned,return from call to `uninit`,assigned,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "uninitialized_value", "start_line": 70, "end_line": 76}}
{"id": "uninit_014", "source_file": "pulse/uninit.c", "original_function_name": "get_field_address_good", "anonymized_function_name": "get_field_address", "function_code": "void get_field_address() {\n  struct uninit_s* s = (struct uninit_s*)malloc(2 * sizeof(int));\n  if (s) {\n    int* p = &s->f1;\n  }\n  free(s);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 83, "end_line": 89}}
{"id": "uninit_015", "source_file": "pulse/uninit.c", "original_function_name": "init_f1", "anonymized_function_name": "init_f1", "function_code": "void init_f1(struct uninit_s* p) { p->f1 = 5; }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 91, "end_line": 91}}
{"id": "uninit_016", "source_file": "pulse/uninit.c", "original_function_name": "interprocedural_struct_good", "anonymized_function_name": "interprocedural_struct", "function_code": "void interprocedural_struct() {\n  struct uninit_s s;\n  init_f1(&s);\n  int y = s.f1;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": ["void init_f1(struct uninit_s* p) { p->f1 = 5; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 93, "end_line": 97}}
{"id": "uninit_017", "source_file": "pulse/uninit.c", "original_function_name": "interprocedural_struct_bad", "anonymized_function_name": "interprocedural_struct", "function_code": "void interprocedural_struct() {\n  struct uninit_s s;\n  init_f1(&s);\n  int y = s.f2;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": ["void init_f1(struct uninit_s* p) { p->f1 = 5; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 102, "severity": "ERROR", "trace": "struct field address `f2` created,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "uninitialized_value", "start_line": 99, "end_line": 103}}
{"id": "uninit_018", "source_file": "pulse/uninit.c", "original_function_name": "malloc_array_good", "anonymized_function_name": "malloc_array", "function_code": "void malloc_array(int len) {\n  char* o = (char*)malloc(len);\n  if (o) {\n    o[0] = 'a';\n    char c = o[0];\n  }\n  free(o);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 105, "end_line": 112}}
{"id": "uninit_019", "source_file": "pulse/uninit.c", "original_function_name": "havoc_calling_unknown_struct_good", "anonymized_function_name": "havoc_calling_unknown_struct", "function_code": "void havoc_calling_unknown_struct() {\n  struct uninit_s x = unknown_wrapper();\n  int y = x.f1;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 118, "end_line": 121}}
{"id": "uninit_020", "source_file": "pulse/uninit.c", "original_function_name": "malloc_array_bad_FN", "anonymized_function_name": "malloc_array_bad_FN", "function_code": "void malloc_array_bad_FN(int len) {\n  char* o = (char*)malloc(len);\n  if (o) {\n    o[0] = 'a';\n    char c = o[1];\n  }\n  free(o);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 123, "end_line": 130}}
{"id": "uninit_021", "source_file": "pulse/uninit.c", "original_function_name": "local_array_good", "anonymized_function_name": "local_array", "function_code": "void local_array() {\n  char o[10];\n  o[0] = 'a';\n  char c = o[0];\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 132, "end_line": 136}}
{"id": "uninit_022", "source_file": "pulse/uninit.c", "original_function_name": "local_array_bad_FN", "anonymized_function_name": "local_array_bad_FN", "function_code": "void local_array_bad_FN() {\n  char o[10];\n  o[0] = 'a';\n  char c = o[1];\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 138, "end_line": 142}}
{"id": "uninit_023", "source_file": "pulse/uninit.c", "original_function_name": "read_g1_f1", "anonymized_function_name": "read_g1_f1", "function_code": "void read_g1_f1(struct uninit_nested* x) { int y = x->g1.f1; }\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_nested {\n  struct uninit_s g1;\n  int g2;\n};", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 149, "end_line": 149}}
{"id": "uninit_024", "source_file": "pulse/uninit.c", "original_function_name": "nested_struct_good", "anonymized_function_name": "nested_struct", "function_code": "void nested_struct() {\n  struct uninit_nested x;\n  x.g1.f1 = 42;\n  read_g1_f1(&x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_nested {\n  struct uninit_s g1;\n  int g2;\n};", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": ["void read_g1_f1(struct uninit_nested* x) { int y = x->g1.f1; }\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 151, "end_line": 155}}
{"id": "uninit_025", "source_file": "pulse/uninit.c", "original_function_name": "nested_struct_bad", "anonymized_function_name": "nested_struct", "function_code": "void nested_struct() {\n  struct uninit_nested x;\n  x.g1.f2 = 42;\n  read_g1_f1(&x);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_nested {\n  struct uninit_s g1;\n  int g2;\n};", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": ["void read_g1_f1(struct uninit_nested* x) { int y = x->g1.f1; }\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 160, "severity": "ERROR", "trace": "struct field address `g1.f1` created,when calling `read_g1_f1` here,parameter `x` of read_g1_f1,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "uninitialized_value", "start_line": 157, "end_line": 161}}
{"id": "uninit_026", "source_file": "pulse/uninit.c", "original_function_name": "init_ptr_zero", "anonymized_function_name": "init_ptr_zero", "function_code": "void init_ptr_zero(int* ptr, int i) {\n  if (i != 0) {\n    *ptr = 42;\n  } else {\n    *(ptr + i) = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 163, "end_line": 169}}
{"id": "uninit_027", "source_file": "pulse/uninit.c", "original_function_name": "call_init_ptr_zero_good", "anonymized_function_name": "call_init_ptr_zero", "function_code": "void call_init_ptr_zero() {\n  int x;\n  init_ptr_zero(&x, 0);\n  int y = x;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void init_ptr_zero(int* ptr, int i) {\n  if (i != 0) {\n    *ptr = 42;\n  } else {\n    *(ptr + i) = 42;\n  }\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 171, "end_line": 175}}
{"id": "uninit_028", "source_file": "pulse/uninit.c", "original_function_name": "uninit_if_zero_bad", "anonymized_function_name": "uninit_if_zero", "function_code": "int uninit_if_zero(int a) {\n  int x;\n  if (a == 0) {\n    int y = x + 1;\n    int z = 4;\n    return z;\n  }\n  return 10;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "PULSE_UNINITIALIZED_VALUE", "line_offset": 3, "absolute_line": 180, "severity": "ERROR", "trace": "variable `x` declared here,read to uninitialized value occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "uninitialized_value", "start_line": 177, "end_line": 185}}
{"id": "uninit_029", "source_file": "pulse/uninit.c", "original_function_name": "uninit_interproc_manifest_bad", "anonymized_function_name": "uninit_interproc_manifest", "function_code": "void uninit_interproc_manifest() {\n  int x = uninit_if_zero_bad(0);\n  if (x == 4) {\n    int* p = NULL;\n    *p = 42; // NPE to test that uninit didn't terminate the symbolic execution\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["int uninit_if_zero_bad(int a) {\n  int x;\n  if (a == 0) {\n    int y = x + 1;\n    int z = 4;\n    return z;\n  }\n  return 10;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 191, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 187, "end_line": 193}}
{"id": "uninit_030", "source_file": "pulse/uninit.c", "original_function_name": "check_range", "anonymized_function_name": "check_range", "function_code": "void check_range(int range_var_valid, int* range_var) {\n  if (range_var_valid) {\n    *range_var = *range_var + 1;\n  }\n\n  assert(range_var_valid >= 0 && range_var_valid <= 1);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 197, "end_line": 203}}
{"id": "uninit_031", "source_file": "pulse/uninit.c", "original_function_name": "check_range_wrapper", "anonymized_function_name": "check_range_wrapper", "function_code": "void check_range_wrapper(int range_var_valid, int* range_var) {\n  check_range(range_var_valid, range_var);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void check_range(int range_var_valid, int* range_var) {\n  if (range_var_valid) {\n    *range_var = *range_var + 1;\n  }\n\n  assert(range_var_valid >= 0 && range_var_valid <= 1);\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 205, "end_line": 207}}
{"id": "uninit_032", "source_file": "pulse/uninit.c", "original_function_name": "uninit_var_not_read_interproc_ok", "anonymized_function_name": "uninit_var_not_read_interproc", "function_code": "void uninit_var_not_read_interproc() {\n  int range_var_valid = 0;\n  int range_var;\n  check_range_wrapper(range_var_valid, &range_var);\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>"], "dependencies": ["void check_range_wrapper(int range_var_valid, int* range_var) {\n  check_range(range_var_valid, range_var);\n}\n"], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": true, "category": "safe", "start_line": 209, "end_line": 213}}
{"id": "uninit_033", "source_file": "pulse/uninit.c", "original_function_name": "call_init_by_conditionaql_exp_ok", "anonymized_function_name": "call_init_by_conditionaql_exp", "function_code": "int call_init_by_conditionaql_exp(int b) {\n  struct uninit_s x = init_by_conditional_exp(b);\n  return x.f1;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct uninit_s {\n  int f1;\n  int f2;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 223, "end_line": 226}}
{"id": "uninit_034", "source_file": "pulse/uninit.c", "original_function_name": "build_struct_during_var_init_ok", "anonymized_function_name": "build_struct_during_var_init", "function_code": "int build_struct_during_var_init() {\n  struct my_pair p = twice(42);\n  return p.x + p.y;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct my_pair {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 250, "end_line": 253}}
{"id": "uninit_035", "source_file": "pulse/uninit.c", "original_function_name": "memset_init_ok", "anonymized_function_name": "memset_init", "function_code": "int memset_init() {\n  struct my_pair pair;\n  memset(&pair, '\\0', sizeof(struct my_pair));\n  return pair.x + pair.y;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct my_pair {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 261, "end_line": 265}}
{"id": "uninit_036", "source_file": "pulse/uninit.c", "original_function_name": "memset_wrapper_init_ok", "anonymized_function_name": "memset_wrapper_init", "function_code": "int memset_wrapper_init() {\n  struct my_pair pair;\n  set_pair_to_zero(&pair);\n  return pair.x + pair.y;\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct my_pair {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 271, "end_line": 275}}
{"id": "uninit_037", "source_file": "pulse/uninit.c", "original_function_name": "memset_wrapper_value_bad", "anonymized_function_name": "memset_wrapper_value", "function_code": "void memset_wrapper_value(struct my_pair* pair) {\n  set_pair_to_zero(pair);\n  if (pair->x == 0 && pair->y == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <assert.h>", "#include <stdlib.h>", "struct my_pair {\n  int x;\n  int y;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 4, "absolute_line": 281, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 277, "end_line": 283}}
{"id": "unsigned_values_001", "source_file": "pulse/unsigned_values.c", "original_function_name": "signed_int_bad", "anonymized_function_name": "signed_int", "function_code": "void signed_int() {\n  int x = returnSigned();\n  if (x < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 30, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 25, "end_line": 32}}
{"id": "unsigned_values_002", "source_file": "pulse/unsigned_values.c", "original_function_name": "signed_int_ptr_bad", "anonymized_function_name": "signed_int_ptr", "function_code": "void signed_int_ptr() {\n  int* x = returnSigned();\n  if (*x < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 54, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 49, "end_line": 56}}
{"id": "unsigned_values_003", "source_file": "pulse/unsigned_values.c", "original_function_name": "signed_field_bad", "anonymized_function_name": "signed_field", "function_code": "void signed_field() {\n  struct foo* x = returnFoo();\n  if (x->signed_int < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>", "struct foo {\n  unsigned int unsigned_int;\n  int signed_int;\n};"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 81, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 76, "end_line": 83}}
{"id": "unsigned_values_004", "source_file": "pulse/unsigned_values.c", "original_function_name": "signed_array_bad", "anonymized_function_name": "signed_array", "function_code": "int signed_array() {\n  int* a = returnSignedArray();\n  if (a[0] < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n", "includes": ["#include <stdlib.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 5, "absolute_line": 105, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 100, "end_line": 107}}
{"id": "var_arg_001", "source_file": "pulse/var_arg.c", "original_function_name": "sum", "anonymized_function_name": "sum", "function_code": "int sum(int n, ...) {\n  va_list args;\n  va_start(args, n);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum += va_arg(args, int);\n  }\n  va_end(args);\n  return sum;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdarg.h>"], "dependencies": [], "ground_truth": {"has_bug": false, "bugs": []}, "metadata": {"requires_interprocedural": false, "category": "safe", "start_line": 11, "end_line": 20}}
{"id": "var_arg_002", "source_file": "pulse/var_arg.c", "original_function_name": "sum_one_then_npe_bad", "anonymized_function_name": "sum_one_then_npe", "function_code": "void sum_one_then_npe() {\n  int one = sum(1, 1);\n  int* p = NULL;\n  *p = one;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdarg.h>"], "dependencies": ["int sum(int n, ...) {\n  va_list args;\n  va_start(args, n);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum += va_arg(args, int);\n  }\n  va_end(args);\n  return sum;\n}\n"], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 25, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": true, "category": "nullptr_dereference", "start_line": 22, "end_line": 26}}
{"id": "var_arg_003", "source_file": "pulse/var_arg.c", "original_function_name": "unknown_sum_one_then_npe_bad", "anonymized_function_name": "unknown_sum_one_then_npe", "function_code": "void unknown_sum_one_then_npe() {\n  int one = unknown_sum(1, 1);\n  int* p = NULL;\n  *p = one;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdarg.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 58, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 55, "end_line": 59}}
{"id": "var_arg_004", "source_file": "pulse/var_arg.c", "original_function_name": "unknown_sum_four_then_npe_bad", "anonymized_function_name": "unknown_sum_four_then_npe", "function_code": "void unknown_sum_four_then_npe() {\n  int four = unknown_sum(4, 1, 1, 1, 1);\n  int* p = NULL;\n  *p = four;\n}\n", "includes": ["#include <stdlib.h>", "#include <stdarg.h>"], "dependencies": [], "ground_truth": {"has_bug": true, "bugs": [{"bug_type": "NULLPTR_DEREFERENCE", "line_offset": 3, "absolute_line": 64, "severity": "ERROR", "trace": "is assigned to the null pointer,assigned,invalid access occurs here"}]}, "metadata": {"requires_interprocedural": false, "category": "nullptr_dereference", "start_line": 61, "end_line": 65}}
